import types
import typing
import pandas as pd
from copy import deepcopy
import rotifer
logger = rotifer.logging.getLogger(__name__)

class SequenceCursor:
    def getids(self, obj):
        """
        Extract accessions from the objects generated by parser().

        Returns
        -------
        A set of strings.
        """
        import typing
        if isinstance(obj,list) or isinstance(obj,tuple):
            return set([ x.id for x in obj ])
        else:
            return {obj.id}

class IPGCursor:
    @property
    def columns(self):
        return self._columns + self._added_columns

    def getids(self,obj):
        if not isinstance(obj,list):
            obj = [obj]
        ids = set()
        for o in obj:
            ids.update(set(o.pid))
            ids.update(set(o.representative))
        return ids

class GenomeCursor:
    def getids(self,obj):
        if isinstance(obj,types.NoneType):
            return set()
        elif isinstance(obj,set):
            return deepcopy(obj)
        elif not isinstance(obj,list):
            obj = [obj]
        assemblies = set()
        for s in obj:
            if hasattr(s,"assembly"):
                if isinstance(s.assembly,str):
                    assemblies.add(s.assembly)
                else:
                    logger.warn(f'Unknown assembly type {type(assembly)}: {assembly}')
            elif hasattr(s,"dbxrefs") and isinstance(s.dbxrefs,list):
                for x in s.dbxrefs:
                    if 'Assembly:' in x:
                        assemblyID = x.split(':')[-1]
                        assemblies.add(assemblyID)
        return assemblies

    def fetcher(self, accession):
        tries = self.tries
        targets = self.parse_ids(accession)
        stream = []
        for acc in targets:
            fh = self.open_genome(acc)
            if fh == None:
                continue
            fh.assembly = acc
            stream.append(fh)
        self.tries = tries
        return stream

    def parser(self, stream, accession):
        from Bio import SeqIO
        stack = []
        for fh in stream:
            if isinstance(fh,types.NoneType):
                continue
            for s in SeqIO.parse(fh,"genbank"):
                setattr(s,"assembly",fh.assembly)
                stack.append(s)
            fh.close()
        return stack

class GenomeFeaturesCursor(GenomeCursor):
    def getids(self,obj):
        if isinstance(obj,types.NoneType):
            return set()
        elif isinstance(obj,set):
            return deepcopy(obj)
        elif isinstance(obj,list):
            return set([ x.assembly for x in obj ])
        elif isinstance(obj,pd.DataFrame) and "assembly" in obj.columns:
            return set(obj.assembly)
        else:
            raise TypeError(f'Unknown object type {type(obj)}: {obj}')

    def parser(self, stream, accession):
        from Bio import SeqIO
        from rotifer.genome.utils import seqrecords_to_dataframe
        if not isinstance(stream, list):
            stream = [stream]
        data = []
        for fh in stream:
            datum = SeqIO.parse(fh,"genbank")
            datum = seqrecords_to_dataframe(
                datum,
                exclude_type = self.exclude_type,
                autopid = self.autopid,
                assembly = fh.assembly,
                codontable = self.codontable,
            )
            data.append(datum)
            fh.close()
        if len(data) > 0:
            data = pd.concat(data)
        else:
            data = seqrecords_to_dataframe([])
        return data

    def fetchall(self, accessions, *args, **kwargs):
        """
        Fetch all accessions as a single dataframe.

        Parameters
        ----------
        accessions: list of strings
          Database accessions

        Returns
        -------
        Pandas dataframe or derived class.
        """
        from rotifer.genome.utils import seqrecords_to_dataframe
        stack = []
        for df in self.fetchone(accessions):
            stack.append(df)
        if stack:
            return pd.concat(stack, ignore_index=True)
        else:
            return seqrecords_to_dataframe([])

class GeneNeighborhoodCursor:
    def getids(self, obj, ipgs=None):
        import types

        # extract ids from dataframe
        if isinstance(obj,pd.DataFrame):
            # Load columns
            columns = self.column
            if not isinstance(columns,typing.Iterable) or isinstance(columns,str):
                columns = [columns]
            else:
                columns = list(columns)

            # when searching for proteins, ensure all columns with protein IDs are used
            pids = ['pid','replaced','representative']
            if set(columns).intersection(pids):
                columns += [ x for x in pids if x not in columns ]

            # Load identifiers from object
            ids = set()
            for col in columns:
                if col in obj.columns:
                    ids.update(set(obj[col].dropna().drop_duplicates()))

        # If obj is not a Pandas Dataframe
        elif not isinstance(obj,typing.Iterable) or isinstance(obj,str):
            ids = {obj}
        elif isinstance(obj,typing.Iterable):
            ids = set(obj)
        else:
            logger.error(f'Unknown type {type(obj)}')

        # Add synonyms from IPGs
        if not isinstance(ipgs,types.NoneType):
            ipgids = ipgs[ipgs.pid.isin(ids) | ipgs.representative.isin(ids)].id
            ipgids = ipgs[ipgs.id.isin(ipgids)]
            ids.update(ipgids.pid.dropna())
            ids.update(ipgids.representative.dropna())

        return ids

    def ipgs_to_dict(self, ipgs, column='assembly'):
        d = { k: v.set_index('pid').representative.to_dict() for k,v in ipgs.groupby(column) }
        return d

    def ipg_proteins(self, ipgs):
        allipgids = set(ipgs.pid).union(ipgs.representative.drop_duplicates())
        return allipgids

    def genome_ids(self, obj):
        if not isinstance(obj,list):
            obj = [obj]
        ids = set()
        for o in obj:
            ids.update(o[self._target_column].drop_duplicates().dropna())
        return ids

    def fetchall(self, accessions, ipgs=None):
        """
        Fetch all neighbors from nucleotide sequences.

        Parameters
        ----------
        accessions: list of strings
          NCBI protein identifiers

        Returns
        -------
        rotifer.genome.data.NeighborhoodDF
        """
        stack = []
        for df in self.fetchone(accessions, ipgs=ipgs):
            stack.append(df)
        if stack:
            return pd.concat(stack, ignore_index=True)
        else:
            return seqrecords_to_dataframe([])

