__doc__ = """
Rotifer connections to local databases
======================================
"""

import re
import os
import types
import typing
import subprocess
import numpy as np
import pandas as pd
from Bio import SeqIO
from io import StringIO

import rotifer
from rotifer import GlobalConfig
from rotifer.core.functions import loadConfig
import rotifer.devel.beta.sequence as rdbs
logger = rotifer.logging.getLogger(__name__)

# Defaults
config = loadConfig(__name__.replace('rotifer.',':'), defaults = {
    'local_database_path': os.path.join(GlobalConfig['data'],"fadb","nr","nr"),
})

class FastaCursor(rotifer.db.core.SimpleParallelProcessCursor):
    """
    Fetch biomolecular sequences using Easel's esl-sfetch.

    Parameters
    ----------
    database_path: string
      Path to a FASTA file.
    batch_size: int, default 1
      Number of accessions per batch
    threads: integer, default 3
      Number of simultaneous threads to run
    progress: boolean, deafult False
      Whether to print a progress bar

    """
    def __init__(
            self,
            database_path=config["local_database_path"],
            batch_size=200,
            threads=int(np.floor(os.cpu_count()/2)),
            progress=False,
            tries=1,
        ):
        super().__init__(batch_size=batch_size, threads=threads, progress=progress, tries=tries)
        self.executable = "esl-sfetch"
        if isinstance(database_path,str) or not isinstance(database_path,typing.Iterable):
            database_path = [ database_path ]
        self.path = []
        for p in database_path:
            if not os.path.exists(p):
                logger.error(f'{p}: no such file!')
                continue
            if not os.path.exists(p + ".ssi"):
                logger.warn(f'Building {self.executable} index for {p}...')
                try:
                    subprocess.run([self.executable,"--index",p])
                except:
                    logger.error("Unable to create index for file {p} ({self.executable})")
                    continue
            self.path.append(p)
        if len(self.path) == 0:
            logger.critical("No index or database for executable {self.executable} in {self.path}")

    def _clean_description(self, seqrec):
        seqrec.description = re.sub("\x01.+", "", seqrec.description.replace(seqrec.id, "").lstrip())
        return seqrec

    def getids(self, obj):
        """
        Extract accessions from the objects generated by parser().

        Returns
        -------
        A set of strings.
        """
        if isinstance(obj,list) or isinstance(obj,tuple):
            return set([ x.id for x in obj ])
        else:
            return {obj.id}

    def __getitem__(self, accession):
        result = []
        for db in self.path:
            result = super().__getitem__(accession, db)
            if not isinstance(result,types.NoneType) and len(result) > 0:
                break
        return result

    def fetcher(self, accession, db, *args, **kwargs):
        """
        Fetch one sequence from the database.

        Returns
        -------
        A Bio.SeqRecord object
        """
        stream = subprocess.run(["esl-sfetch",db,accession], capture_output=True)
        if stream.stderr:
            error = f'Esl-sfetch failed: no accession {accession} in database {db}'
            self.update_missing(accession, error)
            raise RuntimeError(error)
        else:
            stream = stream.stdout.decode()
            stream = StringIO(stream)
            return stream

    def parser(self, stream, accession, *args, **kwargs):
        sequence = SeqIO.read(stream,"fasta")
        sequence = self._clean_description(sequence)
        stream.close()
        return sequence

