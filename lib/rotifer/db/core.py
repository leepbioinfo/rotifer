import types
import typing
import pandas as pd

# Rotifer
import rotifer
logger = rotifer.logging.getLogger(__name__)

class BaseCursor:
    """
    Generic database cursor abstract interface.

    Parameters
    ----------
    batch_size: int, default 1
      Number of accessions per batch
    threads: integer, default 3
      Number of simultaneous threads to run
    progress: boolean, deafult False
      Whether to print a progress bar
    tries: int, default 3
      Number of attempts to download each batch

    """
    def __init__(self, progress=False, *args, **kwargs):
        self.progress = progress
        self.__name__ = str(type(self)).split("'")[1]
        self._missing = dict() # Keys are accessions, values are lists of three elements
        self.giveup = set() # List of errors that will prevent further attempts to use failed accessions
        self.maxgetitem = 1 # Maximum number of arguments accepted by __getitem__()

    def parse_ids(self, accessions, as_string=True):
        """
        Convert a list of accessions into a set object

        Usage
        -----
        setobj = cursor.parse_ids(["acc1","acc2"])

        Parameters
        ----------
        as_string : boolean, default True
          Convert individual accessions to strings

        Rational
        --------
        Cursors usually receive a list of valid database
        identifiers as input but such a list can be given
        as strings, lists, Pandas series or other objects.

        This method ensures that the input converges into
        a standard representation, i.e. a Python set.
        """
        from copy import deepcopy
        targets = deepcopy(accessions)
        if isinstance(targets,str):
            targets = targets.split(",") # Useful for Entrez... remove?
        elif not isinstance(targets,typing.Iterable):
            targets = [ targets ]
        if as_string:
            targets = [ str(x) for x in targets ]
        targets = set(targets)
        return targets

    @property
    def missing(self):
        return pd.DataFrame(self._missing, index="error class retry".split(" ")).T

    def missing_ids(self, retry=None):
        """
        Retrieve accessions not found in the target database.

        Parameters
        ----------
        retry: boolean, default None
          Filter accession based on whether they might
          still be recovered (retry=True) or not (retry=False)
        """
        if isinstance(retry, types.NoneType):
            return set(sorted(list(self._missing.keys())))
        else:
            return set(sorted([ x for x in self._missing.keys() if self._missing[x][2] == retry ]))

    def update_missing(self, accessions=[], error=None, retry=None, data=None, *args, **kwargs):
        """
        Update or add entries to the registry of missing entries.

        Parameters
        ----------
        accessions: list, tuple or set
          Database identifiers
        error: string, default None
          A string describing the latest error
        retry: boolean, default None
          Whether the error is recoverable or not
        data: dictionary, default None
          A dictionary that matches the internal
          registry, with accessions as keys and
          three-elements lists as values.

          If using this parameter, error and retry
          are ignored.
        """
        if isinstance(data, types.NoneType):
            if isinstance(retry,types.NoneType):
                retry = True
                if not isinstance(error,types.NoneType):
                    for x in self.giveup:
                        if x in error:
                            retry = False
                            break
            err = [error, self.__name__, retry]
            targets = self.parse_ids(accessions)
            for x in targets:
                if error == None:
                    if x in self._missing:
                        err[0] = self._missing[x][0]
                    else:
                        err[0] = "Unknown error"
                self._missing[x] = err
        else:
            self._missing.update(data)
            retry = any([ v[2] for k,v in data.items() ])
        return retry

    def remove_missing(self, accessions=None):
        """
        Unregister missing accessions.

        Parameters
        ----------
        accessions: list of strings or None
          If set to None, all entries in the cache will be removed
        """
        if isinstance(accessions,types.NoneType):
            old = self._missing.copy()
            self._missing = dict()
            return old
        else:
            for k in self.parse_ids(accessions):
                self._missing.pop(k, None)

    def getids(self, obj):
        """
        Extract accessions from the objects generated by parser().

        Returns
        -------
        A set of strings.
        """
        return NotImplementedError(f'Method getids() must be implemented by descendants')

    def __getitem__(self, accession, *args, **kwargs):
        """
        Fetch data from the database.

        Parameters
        ----------
        accession: string
          Database entry identifier.

        """
        raise NotImplementedError(f'Method __getitem__() must be implemented by descendants')

    def fetchone(self, accessions, *args, **kwargs):
        """
        Asynchronously fetch sequences data from a database.
        Note: input order is not preserved.

        Parameters
        ----------
        accessions: list of strings
          Database entry identifiers.

        Returns
        -------
        A generator for Bio.SeqRecord objects
        """
        raise NotImplementedError(f'Method fetchone() must be implemented by descendants')

    def fetchall(self, accessions, *args, **kwargs):
        """
        Fetch all data.
        Note: input order is not preserved.

        Parameters
        ----------
        accessions: list of strings
         Database entry identifiers 
        """
        raise NotImplementedError(f'Method fetchall() must be implemented by descendants')

if __name__ == '__main__':
    pass
