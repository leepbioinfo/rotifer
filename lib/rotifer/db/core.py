import types
import typing
import pandas as pd

# Rotifer
import rotifer
import rotifer.db.methods
logger = rotifer.logging.getLogger(__name__)

class BaseCursor:
    """
    Generic database cursor abstract interface.

    Parameters
    ----------
    batch_size: int, default 1
      Number of accessions per batch
    threads: integer, default 3
      Number of simultaneous threads to run
    progress: boolean, deafult False
      Whether to print a progress bar
    tries: int, default 3
      Number of attempts to download each batch

    """
    def __init__(self, progress=False, *args, **kwargs):
        self.progress = progress
        self.__name__ = str(type(self)).split("'")[1]
        self._missing = dict()
        self.giveup = set() # List of errors that will prevent further attempts to use failed accessions
        self.maxgetitem = 1 # Maximum number of arguments accepted by __getitem__()

    def parse_ids(self, accessions, as_string=True):
        """
        Convert a list of accessions into a set object

        Usage
        -----
        setobj = cursor.parse_ids(["acc1","acc2"])

        Parameters
        ----------
        as_string : boolean, default True
          Convert individual accessions to strings

        Rational
        --------
        Cursors usually receive a list of valid database
        identifiers as input but such a list can be given
        as strings, lists, Pandas series or other objects.

        This method ensures that the input converges into
        a standard representation, i.e. a Python set.
        """
        from copy import deepcopy
        targets = deepcopy(accessions)
        if isinstance(targets,str):
            targets = targets.split(",") # Useful for Entrez... remove?
        elif not isinstance(targets,typing.Iterable):
            targets = [ targets ]
        if as_string:
            targets = [ str(x) for x in targets ]
        targets = set(targets)
        return targets

    @property
    def missing(self):
        return pd.DataFrame(self._missing, index="error class retry".split(" ")).T

    def missing_ids(self):
        return set(sorted(list(self._missing.keys())))

    def update_missing(self, accessions=[], error=None, retry=None, data=None, *args, **kwargs):
        if isinstance(data, types.NoneType):
            if isinstance(retry,types.NoneType):
                retry = True
                if not isinstance(error,types.NoneType):
                    for x in self.giveup:
                        if x in error:
                            retry = False
                            break
            err = [error, self.__name__, retry]
            targets = self.parse_ids(accessions)
            for x in targets:
                if error == None:
                    if x in self._missing:
                        err[0] = self._missing[x][0]
                    else:
                        err[0] = "Unknown error"
                self._missing[x] = err
        else:
            self._missing.update(data)

    def remove_missing(self, accessions=None):
        """
        Unregister missing accessions.

        Parameters
        ----------
        accessions: list of strings or None
          If set to None, all entries in the cache will be removed
        """
        if accessions == None:
            old = self._missing.copy()
            self._missing = dict()
            return old
        else:
            for k in accessions:
                self._missing.pop(k, None)

    def getids(self, obj):
        """
        Extract accessions from the objects generated by parser().

        Returns
        -------
        A set of strings.
        """
        return NotImplementedError(f'Method getids() must be implemented by descendants')

    def __getitem__(self, accession, *args, **kwargs):
        """
        Fetch data from the database.

        Parameters
        ----------
        accession: string
          Database entry identifier.

        """
        raise NotImplementedError(f'Method __getitem__() must be implemented by descendants')

    def fetchone(self, accessions, *args, **kwargs):
        """
        Asynchronously fetch sequences data from a database.
        Note: input order is not preserved.

        Parameters
        ----------
        accessions: list of strings
          Database entry identifiers.

        Returns
        -------
        A generator for Bio.SeqRecord objects
        """
        raise NotImplementedError(f'Method fetchone() must be implemented by descendants')

    def fetchall(self, accessions, *args, **kwargs):
        """
        Fetch all data.
        Note: input order is not preserved.

        Parameters
        ----------
        accessions: list of strings
         Database entry identifiers 
        """
        raise NotImplementedError(f'Method fetchall() must be implemented by descendants')

class BaseGeneNeighborhoodCursor(BaseCursor):
    def __init__(
            self,
            column = 'pid',
            before = 7,
            after = 7,
            min_block_distance = 0,
            strand = None,
            fttype = 'same',
            eukaryotes = False,
            exclude_type = ['gene','mRNA','source'],
            autopid = True,
            codontable = 'Bacterial',
            progress=False,
            tries=3,
            batch_size=None,
            threads=10,
            *args, **kwargs):
        super().__init__(progress=progress, *args, **kwargs)
        self.column = column
        self.before = before
        self.after = after
        self.min_block_distance = min_block_distance
        self.strand = strand
        self.fttype = fttype
        self.eukaryotes = eukaryotes
        self.exclude_type = exclude_type
        self.autopid = autopid
        self.codontable = codontable
        self.tries = tries
        self.batch_size = batch_size
        self.threads = threads
        self._missing = pd.DataFrame(columns=["noipgs","eukaryote","assembly","error",'class'])

    @property
    def missing(self):
        return self._missing

    def update_missing(self, accessions, assembly, error):
        err = [False,False,assembly,error,str(type(self)).split("'")[1]]
        if "Eukaryotic" in error:
            err[1] = True
        if "IPG" in error:
            err[0] = True
        if not isinstance(accessions,typing.Iterable) or isinstance(accessions,str):
            accessions = [accessions]
        for x in accessions:
            self._missing.loc[x] = err

    def getids(self, obj, ipgs=None):
        import types

        # extract ids from dataframe
        if isinstance(obj,pd.DataFrame):
            # Load columns
            columns = self.column
            if not isinstance(columns,typing.Iterable) or isinstance(columns,str):
                columns = [columns]
            else:
                columns = list(columns)

            # when searching for proteins, ensure all columns with protein IDs are used
            pids = ['pid','replaced','representative']
            if set(columns).intersection(pids):
                columns += [ x for x in pids if x not in columns ]

            # Load identifiers from object
            ids = set()
            for col in columns:
                if col in obj.columns:
                    ids.update(set(obj[col].dropna()))

        # If obj is a list
        elif not isinstance(obj,typing.Iterable) or isinstance(obj,str):
            ids = {obj}
        elif isinstance(obj,typing.Iterable):
            ids = set(obj)
        else:
            logger.error(f'Unknown type {type(obj)}')

        # Add synonyms from IPGs
        if not isinstance(ipgs,types.NoneType):
            ipgids = ipgs[ipgs.pid.isin(ids) | ipgs.representative.isin(ids)].id
            ipgids = ipgs[ipgs.id.isin(ipgids)]
            ids.update(ipgids.pid.dropna())
            ids.update(ipgids.representative.dropna())

        return ids

if __name__ == '__main__':
    pass
