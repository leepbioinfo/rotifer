#!/usr/bin/env perl

# LIBRARIES and PRAGMAS: start
use FindBin;
use lib "$FindBin::RealBin/../perl/lib";
use Bio::OntologyIO;
use Carp::Clan;
use Cwd qw(abs_path);
use File::Basename;
use File::Find;
use File::Spec;
use File::Which qw(which);
use Memoize;
use Rotifer; # Make changes to %ENV
use Rotifer::DB::Base;
use Rotifer::SequenceModel;
use strict;
use warnings;
# LIBRARIES and PRAGMAS: end

# Some attempts at speeding up things
memoize('get_nofseqs_from_fasta');
memoize('get_blastdb_size');
memoize('find_executable');

# MAIN PROGRAM: start
#  Load configuration
my $CONFIG = parse_configuration();

#  Load and select profiles
my ($PROFILES, %LIBRARIES) = load_profiles_from_files($CONFIG);

# Optional: just show selected data and abort
if ($CONFIG->mode eq "show") {
    my @columns = qw(id name domain file extension get_terms);
    if (scalar keys(%$PROFILES)) {
        print join("\t",@columns, 'type'),"\n";
        foreach my $profile (sort { $a->id cmp $b->id } values %$PROFILES) {
            print join("\t", (map { $profile->$_ } @columns), 'profile'),"\n";
        }
    }
    if (scalar keys(%LIBRARIES)) {
        my @ext = (keys(%{$CONFIG->profile_search}), keys(%{$CONFIG->library_search}));
        my $ext = join("|",@ext);
        foreach my $library (sort { $LIBRARIES{$a} cmp $LIBRARIES{$b} } keys %LIBRARIES) {
            my $bn = basename($library, @ext);
            $library =~ /($ext)$/;
            print join("\t", uc($bn), $bn, '-', $library, $1 || "-", "-", 'library'),"\n";
        }
    }
    exit 0;
}

# Run searches
my @IDS = run($CONFIG, $PROFILES, %LIBRARIES);
print join("\n","Submitted jobs:",@IDS),"\n" if ($CONFIG->que && $CONFIG->mode eq "run");
exit 0;
# MAIN PROGRAM: end

#######################################################################
# Subroutines
#######################################################################

# We need to load all data for profiles and select the ones that match
# user criteria. Note that a profile is only available if its file is 
# present in the profile path or the profile is mapped to a domain in
# the profile to domain maps
sub load_profiles_from_files {
    my ($config) = @_;

    # Steps 1 and 2: process ontologies
    # STEP 1: load and process ontologies, marking all users requests for inclusion
    #         and building an index of term identifiers (name, synonym and identifier)
    my %ontologies = (); my $term_index = {}; my @included = ();
    foreach my $file (@{ $config->ontology_file }) {
        my ($ontology) = load_ontologies($config->ontology_format, $file);
        update_term_index($term_index, $ontology);
        select_terms($config, $ontology);
        $ontologies{$ontology->name} = $ontology;
    }
    print STDERR scalar(keys %ontologies)." ontologies were loaded and ".scalar(keys %$term_index)," indexes were built\n" if ($config->debug > 0);
    map { print $_->name,"\t",scalar(keys %{ $term_index->{uc $_->name} }),"\n" if (exists $term_index->{uc $_->name}) } values %ontologies if ($config->debug > 1);

    # Steps 2 to 4: load profiles
    # STEP 2: scan profile path(s), load profiles and identify profile libraries
    my ($profiles, $libraries) = scan_profile_path($config, @{ $config->profile_path });
    my %libpath = map { ($_, 0) } values %$libraries; # Extract library paths
    #map { print join("\t", $_->id, $_->name, $_->file, $_->extension),"\n" } sort { $a->id cmp $b->id || $a->name cmp $b->name } values %$profiles; # Debug
    print STDERR scalar(keys %$profiles)." profiles and ".scalar(keys %libpath)." libraries loaded from files\n" if ($config->debug > 0);

    # STEP 3: detect/load profiles in libraries for any requests that are not ontology terms
    my @unknown = ();
    foreach my $request (keys %{ $config->_include }) {
        next if ($request =~ /^ALL$/o);
        # Below: jump to next request if the current request matches an ontology term or a profile
        # The test in the middle checks whether select_terms detect terms matching the user request
        # This subroutine register these matches by changing the value of $config->_include->{$request} from 0 to 1 
        fetch_profiles_from_libraries($config, $profiles, $request, \%libpath);
        next if ($config->_include->{$request} && !exists $profiles->{$request} && grep { exists $term_index->{$_}->{$request} } keys %$term_index);
        if (exists $libraries->{$request}) { # If a whole library is the only thing that matches the user $request mark it for use
            $libpath{$libraries->{$request}} = -1;
            next;
        }
        push(@unknown, $request) unless (exists $profiles->{$request}); # not all, not a profile and does not match any annotation term
    }
    map { delete $libpath{$_} if ($libpath{$_} >= 0) } keys %libpath if (grep { $_ != 0 } values %libpath && !$config->_include_all);
    #map { print join("\t", $_->id, $_->name, $_->domain, $_->file, $_->extension, map { ref($_) ? join(":",@{$_}) : $_ } $_->get_terms),"\n" } values %$profiles;
    print STDERR "Ignoring the following unknown queries:\n",join("\n",@unknown),"\n\nLibraries:\n",join("\n",sort keys %libpath),"\n" if (scalar @unknown);
    print STDERR scalar(keys %$profiles)." profiles and ".scalar(keys %libpath)." libraries loaded from files and libraries\n" if ($config->debug > 0);

    # STEP 4: load profile annotations from text tables (profile -> ontology term or profile property)
    my $nofTables = $config->_include_all ? 0 : load_profile_annotations($profiles, \%ontologies, $term_index, @{ $config->annotation });
    #map { print join("\t", $_->id, $_->name, $_->domain, $_->file, $_->extension, map { ref($_) ? join(":",@{$_}) : $_ } $_->get_terms),"\n" } values %$profiles;
    print STDERR "$nofTables annotation tables loaded\n" if ($config->debug > 0);

    # STEP 5: Apply filters based on user criteria and check each profile for mandatory information
    my $removed = $config->_include_all ? 0 : filter_profiles($profiles, \%ontologies, $term_index, $config->_include, $config->_exclude);
    print STDERR scalar(keys %$profiles)." profiles accepted and ".$removed." filtered out\n" if ($config->debug > 0);

    die "No profiles were found to match the user requests. Aborting...\n" unless (scalar(keys %$profiles) || $config->_include_all || scalar(keys %libpath));

    return ($profiles, %libpath);
}

# Load terms
sub load_ontologies {
    my ($format, @files) = @_;

    my @ontologies = ();
    foreach my $file (@files) {
        my $io = Bio::OntologyIO->new(-file=>$file, -format=>$format);
        while (my $ontology = $io->next_ontology) {
            push(@ontologies, $ontology);
        }
        $io->close;
    }

    return @ontologies;
}

# Apply subroutine to all childs of the keys of a given hash (2o. argument)
sub update_term_index {
    my ($index, $ontology) = @_;

    # Select/Create a slot for this ontology
    my $name = $ontology->name;
    $index->{$name} = {} if (!exists $index->{$name});

    foreach my $obj ($ontology->get_all_terms) {
        my @synonyms = map { /\"(.+)\"/; $1 || $_ } $obj->each_synonym;
        foreach my $id ($obj->name, @synonyms) {
            $id = uc($id);
            if (exists $index->{$name}->{$id}) {
                push(@{ $index->{$name}->{$id} }, $obj);
            } else {
                $index->{$name}->{$id} = [ $obj ];
            }
        }
    }

    return $index;
}

# Select terms
sub select_terms {
    my ($config, $ontology) = @_;

    # Include root identifiers to enforce printing of all terms when users explicitly ask for "all" terms
    return 1 if ($config->_include_all);
    #map { $config->_include->{uc $_->name} = 1 } $ontology->get_root_terms;
    #}

    # Selecting nodes for printing
    my @count = ();
    foreach my $obj ($ontology->get_all_terms) {
        # Load and inspect identifiers
        my $excl = 0; my $incl = 0;
        my @synonyms = ($obj->name, map { /\"(.+)\"/; $1 || $_ } $obj->each_synonym);
        foreach my $synonym (@synonyms) {
            $synonym = uc($synonym);
            if ($config->regexp) {
                foreach my $query (keys %{ $config->_exclude }) {
                    if ($synonym =~ /$query/i) {
                        $config->_exclude->{$query} = 1;
                        $excl = 1;
                        last;
                    }
                }
                foreach my $query (keys %{ $config->_include }) {
                    if ($synonym =~ /$query/i) {
                        $config->_include->{$query} = 1;
                        $incl = 1;
                        last;
                    }
                }
            } else {
                if (exists $config->_exclude->{$synonym}) {
                    $config->_exclude->{$synonym} = 1;
                    $excl = 1;
                }
                if (exists $config->_include->{$synonym}) {
                    $config->_include->{$synonym} = 1;
                    $incl = 1;
                }
            }
        }

        # Include terms (node, parents and children)
        if ($incl) {
            # Include node and descendents
            traverse_ontology_graph($ontology, $obj, 'get_child_terms', $config->children,
                sub {
                    my ($onto, $term, $level) = @_;
                    $term->{'_included'} = $level unless (exists $term->{'_included'} && $term->{'_included'} < $level);
                    return 1;
                });
            # Include NO parents
            traverse_ontology_graph($ontology, $obj, 'get_parent_terms', 0,
                sub {
                    my ($onto, $term, $level) = @_;
                    $term->{'_included'} = -$level unless (exists $term->{'_included'} && $term->{'_included'} < $level);
                    return 1;
                });
            push(@count, $_);
        }

        # Exclude terms (node and children only)
        if ($excl) {
            traverse_ontology_graph($ontology, $obj, 'get_child_terms', -1,
                sub {
                    my ($onto, $term, $level) = @_;
                    $term->{'_excluded'} = $level unless (exists $term->{'_excluded'} && $term->{'_excluded'} < $level);
                    return 1;
                });
        }

        $obj->{'_selected_query'} = 1 if ($incl && !$excl);
    } # foreach my $obj ($ontology->get_all_terms)

    return @count;
}

# Traverse directed graph from a term
# If the call back return false, traversal is interrupted
sub traverse_ontology_graph {
    my $status = _traverse_ontology_graph(0, @_);
    #map { delete $_->{'_graph_traversal_visited'} } $_[0]->get_all_terms;
    return $status;
}

sub _traverse_ontology_graph {
    my ($level, $ont, $term, $direction, $depth, $callback, @args) = @_;

    # Run callback subroutine
    my $status = $callback->($ont, $term, $level, @args);
    return 0 unless ($status);

    # Childs
    $level++; # Increment when ascending/descending
    foreach my $child ($ont->$direction($term)) {
        next if ($child eq $term || ($depth != -1 && $level > $depth));
        _traverse_ontology_graph($level, $ont, $child, $direction, $depth, $callback, @args);
    }

    # Reset traversal-specific keys of visited nodes
    return $status;
}

# Scan profile path and load initial set of profiles
sub scan_profile_path {
    my ($config, @path) = @_;

    # Load required library
    my @libs = $config->_exists('library_search') ? keys %{ $config->library_search } : ();
    my $libs = $config->_exists('library_search') ? join("\|",@libs) : "";
    my @ext  = keys %{ $config->profile_search };
    my $ext  = join("\|",@ext);
    my $libraries = {};
    my $profiles  = {};
    find({
            follow => 1,
            wanted => sub {
                if (scalar(@libs) && $File::Find::name =~ /($libs)$/o) {
                    my $libID = basename($File::Find::name, @libs);
                    die "ERROR: name conflict detected!!!! The following files refer to the same library:\n".$libraries->{$libID}."\n$File::Find::name\n"
                    if (exists $libraries->{$libID} && $libraries->{$libID} ne $File::Find::name);
                    $libraries->{uc $libID} = $File::Find::name;
                    return 2;
                };
                return 1 if (-d $File::Find::name || !length($ext) || $File::Find::name !~ /($ext)$/o );
                my $profile = Rotifer::SequenceModel->new(name => basename($File::Find::name, @ext), file => $File::Find::name);
                die "ERROR: name conflict detected!!!! The following files refer to the same profile:\n".$profiles->{$profile->id}->file."\n$File::Find::name\n"
                if (exists $profiles->{$profile->id} && $profiles->{$profile->id}->file ne $File::Find::name);
                my $domain = basename($profile->file, @ext);
                if ($domain =~ /^([^_]+)(\_\S+)?\.\d+$/) { # Parsing domain name for ProfileDB
                    $domain = $1;
                } elsif ($domain =~ /^([-\w]+)$/) {
                    $domain = $1;
                    $domain =~ s/_\d+$//; # Parsing Pfam
                } else {
                    carp "Problem parsing profile $File::Find::name ($domain unparseable)";
                    return 1;
                }
                $profile->domain($domain);
                $config->_include->{$domain} = 1 if (exists $config->_include->{$domain});
                $profiles->{$profile->id} = $profile;
            }}, @path);

    return ($profiles, $libraries);
}

# Associate profile annotations and ontology terms
sub load_profile_annotations {
    my ($profiles, $ontologies, $term_index, @path) = @_;

    # Load Sequence Model Ontology to validate type column
    my ($seqmodel) = load_ontologies("obo", "$FindBin::RealBin/../lib/rotifer/runprofiles/SequenceModel.obo");
    my $smindex    = update_term_index({}, $seqmodel);

    # Load domain mapping as associated terms
    my %seen  = ();
    foreach my $file (@path) {
        # Parse file
        my $i = 0;
        open(MAP,"<$file") || die "Could not read annotation file $file";
        while (<MAP>) {
            chomp;
            next if (/^\s*$/ || /^\#/);
            s/^\s+//; s/\s+$//;
            my @row = split(/\s+/,$_);
            warn "WARNING: row $i in annotation table $file has more than 5 columns! Ignoring extra columns" if (scalar @row > 5);

            # Check if the annotation tag is in our Sequence Model Ontology
            my ($type) = find_terms_by_identifier($seqmodel, $row[1], 1, $smindex);
            die "Unknown annotation tag $row[1] in the second column of file $file (row $i).\nAnnotation tags must be terms or synonyms from the Sequence Model Ontology"
            if (!defined $type);

            # Identifiers
            my $profileID = uc($row[0]);
            if (exists $profiles->{$profileID}) { # Identifier is a profile ID
                my $obj = $profiles->{$profileID};
                if ($type->name eq "Maximum number of iterations") {
                    $obj->number_of_iterations($row[2]);
                } elsif ($type->name eq "Maximum E-value cutoff") {
                    $obj->maximum_evalue_cutoff($row[2]);
                } elsif ($type->name eq "Inclusion threshold") {
                    $obj->inclusion_threshold($row[2]);
                } else { # Ontology terms
                    foreach my $ontology (values %$ontologies) {
                        my @terms = find_terms_by_identifer($ontology, $row[2], 1, $term_index);
                        die "Unknown '$row[1]' $row[2] for profile $profileID in file $file, row $i" unless (scalar @terms);
                        $obj->add_terms($row[1], @terms);
                    }
                }
            } 

            $i++;
        }
        $seen{$file} = 1;
    }

    return scalar(keys %seen);
}

# Apply subroutine to all childs of the keys of a given hash (2o. argument)
sub find_terms_by_identifier {
    my ($ontology, $term, $case, $term_index) = @_;
    $case = 1 if (!defined $case);

    # Use index, if provided
    if (defined $term_index && exists $term_index->{$ontology->name}) {
        my @terms = ();
        if ( exists $term_index->{$ontology->name}->{uc($term)} ) { # Our index is case insensitive
            @terms = @{ $term_index->{$ontology->name}->{uc($term)} };
            if ($case) {
                my @tmp = @terms;
                @terms = ();
                foreach my $tmp (@tmp) {
                    push(@terms, $tmp) if (grep { $term eq $_ } ($tmp->name, $tmp->identifier, map { /\"(.+)\"/; $1 || $_ } $tmp->each_synonym));
                }
            }
        }
        return @terms;
    }

    # No index?
    my @terms = ();
    foreach my $obj ($ontology->get_all_terms) {
        if ($case) { # Case sensitive search
            push(@terms, $obj) if (grep { $term eq $_ } map { $obj->$_ } qw(identifier name each_synonym));
        } else {     # Case insensitive
            push(@terms, $obj) if (grep { uc($term) eq uc($_) } map { $obj->$_ } qw(identifier name each_synonym));
        }
    }

    return @terms;
}

# Search for profiles in single-file profile libraries
# and inform unkown requests
sub fetch_profiles_from_libraries {
    my ($config, $profiles, $request, $libraries) = @_;

    # Try to fetch and associate if successful
    my $conflict = 0; # Check libraries for presence of profiles
    foreach my $library (keys %$libraries) {
        next unless ($config->_exists("profile_fetch"));
        my $profile = Rotifer::SequenceModel->new(name => $request, file => $library);

        # Find the fetcher for this profile
        my $fetch = find_executable($config->profile_fetch->{ $profile->extension });
        $profile->fetcher($fetch) if (defined $fetch);

        # Fetch the profile
        my $matrix = $profile->fetch;
        next unless (defined $matrix);

        # Parse domain name and id from Pfam and update profile
        if ($matrix =~ /^HMMER/) { # Parse Pfam entries
            my ($name) = ($matrix =~ /\bNAME\s+(\S+)\s*\n/);
            my ($id)   = ($matrix =~ /\nACC\s+(\S+)\s*\n/);
            $profile->name($name);
            $profile->id($name);
            $profile->add_terms('dbxref',"PFAM:$id");
        }

        # RPS-BLAST library
        elsif ($matrix =~ /^RPS-BLAST (.+)/) {
            $libraries->{$library}++ if ($request eq uc($1));
            next;
        }

        # Original is valid! Create new and check for conflicts
        my $id = uc($profile->id);
        if (exists $profiles->{$id}) {
            print STDERR join(" ","ERROR: profile",$profile->name,"(ID: $id, file $library) conflicts",$profiles->{$id}->name,"(file:",$profiles->{$id}->file),")\n";
            $conflict++;
            next;
        }

        $libraries->{$library}++; # Count domains from this library
        $profiles->{$id} = $profile;
    } # foreach my $library (keys %$libraries)

    # Check if there are any conflicting profiles
    if ($conflict) {
        print STDERR "ERROR: there are $conflict fatal conflicts between profile unique IDs!!! Aborting...\n";
        exit 1;
    }

    return scalar(keys %{$libraries});
}

# Remove profiles based on user defined selection criteria
# and also test for lack of mandatory information, like
# domain name or a readable profile source
sub filter_profiles {
    my ($profiles, $ontologies, $term_index, $include, $exclude) = @_;

    my @unreadable = (); # List of missing profiles
    my $count = 0; # Number of profiles removed
    PROFILE: foreach my $profileID (keys %$profiles) {
        my $profile = $profiles->{$profileID};
        $profile->domain($profile->name) unless (defined $profile->domain); # When not derived from filename or library

        # Something was included and it is not 'ALL': prepare to 
        # remove all other profiles
        my $remove = exists($include->{'ALL'}) ? 0 : 1;

        # Profile IDs have precedence over other annotations
        # but exclusion has precedence over inclusion
        if (exists $exclude->{$profileID}) {
            $remove = 1;
        } elsif (exists $include->{$profileID} || exists $include->{$profile->domain}) {
            $remove = 0;
        }

        # Inspect annotations
        else {
            ANN: foreach my $key ($profile->get_all_annotation_keys) {
                foreach my $term ($profile->get_terms($key)) {
                    my @terms = ($term);

                    # Annotations are stored as string and we need to find all the corresponding terms in all ontologies
                    if (!ref $term) {
                        @terms = ();
                        foreach my $ontology (values %$ontologies) {
                            push( @terms, find_terms_by_identifier($ontology, $term, 0, $term_index) );
                        }
                    }

                    # Inspect associated annotations: any exclusion is 
                    #print join(" ",$profileID, $key, map { ($_->name, 
                    #					exists $_->{'_included'} ? $_->{'_included'} : "no",
                    #					exists $_->{'_excluded'} ? $_->{'_excluded'} : "no") } @terms),"\n";
                    foreach my $obj (@terms) {
                        if (exists $obj->{'_included'} && exists $obj->{'_excluded'}) {
                            next if ($obj->{'_excluded'} == $obj->{'_included'});
                            if ($obj->{'_excluded'} < $obj->{'_included'}) {
                                $remove = 1;
                                last ANN;
                            }
                        } elsif (exists $obj->{'_included'}) { # Included only
                            $remove = 0;
                        } elsif (exists $obj->{'_excluded'}) { # Excluded only
                            $remove = 1;
                            last ANN;
                        }
                    }
                }
            } # ANN: foreach my $key ($profile->get_all_annotation_keys)
        } # else

        # Remove rejected profiles
        if ($remove) {
            delete $profiles->{$profileID};
            $count++;
            next PROFILE;
        }

        # Check if we can use this profile
        unless (defined $profile->fetch) {
            push(@unreadable, $profile);
        }
    } # PROFILE: foreach my $profileID (keys %$profiles)

    # Check and warn against 
    if (scalar @unreadable) {
        my @unreadable = map { join("\t",$_->name,$_->file) } @unreadable;
        die join("\n","The following profiles cannot be read:",@unreadable),"\n";
    }

    return $count;
}

# This subroutine call appropriate procedures depending on the profile
sub run {
    my ($config, $profiles, %libraries) = @_;
    my @dispatched = (); # IDs of jobs submitted to the farm
    my $conf = basename($config->configfile->[0]);

    # Choose subdirectory structure for output files
    my ($log,$srch) = $config->simple ? (".",".") : ("log","srch");

    # Create output directory tree
    if ($config->mode eq "run" && !exists $ENV{"JOB_ID"}) {
        if ($config->simple) {
            warn "WARNING: overwriting file $conf" if ( -f $conf );
        } else {
            mkdir($config->name) unless (-d $config->name);
            chdir($config->name);
            print STDERR "WARNING: running analysis in directory ".$config->name."\n";
            foreach my $subdir (qw(config srch log)) {
                mkdir($subdir) unless ( -d $subdir );
            }
            $conf = File::Spec->catfile(".","config",$conf);
        }

        # Dump a subset of the current runtime parameters 
        if (-f $conf ) {
            warn "WARNING: A file named $conf already exists in ".$config->name."!! Runprofiles will reuse this file!!!!!";
        } else {
            my @config = grep { !(/^(_|ontology)/ || /^(configfile|configdump|debug|help|children|database|exclude|profile_path|que)$/) } $config->get_options;
            $config->to_file($conf, @config);
        }

        # Place STDIN in a temporary file
        unless ( -t STDIN || scalar(grep { /^\-$/ } keys %{ $config->_include }) ) {
            mkdir('data') unless ( -d "data" );
            open(IN,">data/stdin.fa") || die "Could not create FASTA file for standard input";
            my $ok = 0;
            while (<STDIN>) {
                print IN $_;
                $ok = 1 if /^>\S+/;
            }
            close(IN);
            if ($ok) { # Add to -d option
                #		unshift(@{ $config->database }, relative2absolute("data/stdin"));
                unshift(@{ $config->database }, abs_path("data/stdin"));
            } else {
                unlink('data/stdin.fa');
                unlink('data');
            }
        }
    }

    # Preparing qsub command
    my $qsub = "qsub";
    if ($config->que) {
        $qsub = find_executable($config->program_path->{"qsub"} || "qsub");
        $qsub .= " ".join(" ",%{ $config->program_parameter_qsub });
    }

    # Process profiles
    foreach my $profile (sort { $a->id cmp $b->id } values %$profiles) {
        # Set run parameters
        $profile->number_of_iterations($config->iterations) if (!defined $profile->number_of_iterations);
        $profile->inclusion_threshold($config->threshold)   if (!defined $profile->inclusion_threshold);

        # Find the executable for this profile
        my $programname  = $config->profile_search->{ $profile->extension };
        my $executable = find_executable($programname);
        if (!defined $executable) {
            print STDERR "WARNING: unable to find executable search tool for profile ".$profile->name." ($programname)\n" if ($config->debug > 1);
            next;
        }
        $profile->executable($executable);

        # Running analysis for each sequence database
        foreach my $database (@{ $config->database }) {
            # Apply execution plan restrictions
            if (exists $config->_plan->{$profile->id} && !exists $config->_plan->{$profile->id}{$database}) {
                print STDERR "WARNING: I won't run query ".$profile->name." (".$profile->id.") against database $database\n" if ($config->debug > 2);
                next;
            }

            # Prepare sequence databases
            my ($dbname, $dbpath, $dbext) = prepare_sequence_database($config, $database, $programname);

            # Send to the farm
            if ($config->que) {
                my $out = $profile->name.".${dbname}.out";
                my $err = $profile->name.".${dbname}.err";
                if (!$config->simple) {
                    $out = "$log/$out";
                    $err = "$log/$err";
                }

                # Build command line
                my @cmdline = ($qsub, "-o", $out, "-e", $err);
                push(@cmdline, $0,"--noque","--configfile", $conf, "--profile_path", $profile->file, , "--ontology", "none");
                push(@cmdline, "--database_path", $dbpath) if (defined $dbpath);
                push(@cmdline, "--database", $dbname, $profile->name);

                if ($config->mode eq "test") {
                    print "@cmdline > $log/qsub.out 2> $log/qsub.err\n";
                } else {
                    # Your job-array 7440509.1-5:1 ("runprofiles") has been submitted
                    print "@cmdline > $log/qsub.out 2> $log/qsub.err\n" if ($config->debug > 0);
                    my ($a) = (system("@cmdline > $log/qsub.out 2> $log/qsub.err") >> 8); # 0 if ok
                    if ($a) { # Command failed to execute!
                        print STDERR "Error while trying to execute @cmdline\n";
                        exit 2;
                    }
                    open(QSUB, "<$log/qsub.out") || die "Error while trying to parse qsub's output";
                    while (<QSUB>) {
                        chomp;
                        my ($jobid) = /Your job\S* (\d+)/;
                        push(@dispatched, $jobid);
                    }
                    close(QSUB);
                    sleep(1);
                }
            }

            # Execute locally
            else {
                my $out = "$srch/".$profile->name.".${dbname}.${programname}";
                my $err = "$log/".$profile->name.".${dbname}.${programname}.err";
                if (defined $dbpath) {
                    $dbpath .= "/" unless ($dbpath =~ m|/$|);
                    $dbname = "$dbpath$dbname";
                }
                $dbname .= $dbext if (defined $dbext);
                $dbname =~ s/(\.\d+)?\.p..$// if ($programname =~ /^(psi|t)?blast(all|pgp|n|p|x)?$/i);
                my @cmdline = get_command_line($config, $profile, $dbname); # Prepare command line
                unlink($out) if ( -f $out );
                if ($config->mode eq "test") {
                    print "@cmdline > $out 2> $err\n";
                } else {
                    print "@cmdline > $out 2> $err\n" if ($config->debug > 0);
                    my ($a) = (system("@cmdline > $out 2> $err") >> 8); # 0 if ok
                    if ($a) { # Command failed to execute!
                        print STDERR "Error while trying to execute $cmdline[0]\n";
                        exit 2;
                    }
                    postprocess($config, $profile, $out);
                }
            }
        } # foreach my $database (@{ $config->database })
    } # foreach my $profile (sort { $a->id cmp $b->id } values %$profiles)

    # Process libraries
    if ($config->_exists('library_search')) {
        my @libs = keys %{ $config->library_search };
        foreach my $library (sort keys %libraries) {
            #	    next if ($libraries{$library}); # Ignore libraries that are being used for individual profiles
            my ($libname, $libpath, $extension) = fileparse($library, @libs);
            my $programname = $config->library_search->{ $extension };
            my $executable  = find_executable($programname);

            # Run analysis on each database
            foreach my $database (@{ $config->database }) {
                # Prepare sequence database
                my ($dbname, $dbpath, $dbext) = prepare_sequence_database($config, $database, $programname);

                # Send to the farm
                if ($config->que) {
                    # Output files
                    my $out = "$log/${libname}.${dbname}.out";
                    my $err = "$log/${libname}.${dbname}.err";

                    # Building command line
                    my @cmdline = ($qsub, "-o", $out, "-e", $err);
                    push(@cmdline, $0, "--configfile", $conf, "--noque", "--profile_path", $library, , "--ontology", "none");
                    push(@cmdline, "--database_path", $dbpath) if (defined $dbpath);
                    push(@cmdline, "--database", $dbname, "all");

                    if ($config->mode eq "test") {
                        print "@cmdline > $log/qsub.out 2> $log/qsub.err\n";
                    } else {
                        # Your job-array 7440509.1-5:1 ("runprofiles") has been submitted
                        print "@cmdline\n" if ($config->debug > 0);
                        my ($a) = (system("@cmdline > $log/qsub.out 2> $log/qsub.err") >> 8); # 0 if ok
                        if ($a) { # Command failed to execute!
                            print STDERR "Error while trying to execute @cmdline\n";
                            exit 2;
                        }
                        open(QSUB, "<log/qsub.out") || die "Error while trying to parse qsub's output";
                        while (<QSUB>) {
                            chomp;
                            my ($jobid) = /Your job\S* (\d+)/;
                            push(@dispatched, $jobid);
                        }
                        close(QSUB);
                        sleep(1);
                    }
                }

                # Process libraries locally
                else {
                    my $out = "$srch/${libname}.${dbname}.${programname}";
                    my $err = "$log/${libname}.${dbname}.${programname}.err";
                    if (defined $dbpath) {
                        $dbpath .= "/" unless ($dbpath =~ m|/$|);
                        $dbname = "$dbpath$dbname";
                    }
                    $dbname .= $dbext if (defined $dbext);
                    $dbname =~ s/\.?\d*\.p..$// if ($programname =~ /^blast/i);
                    my @cmdline = get_library_command_line($config, "$libpath$libname", $dbname, $extension);
                    if ($config->mode eq "test") {
                        print "@cmdline > $out 2> $err\n";
                    } else {
                        print "@cmdline > $out 2> $err\n" if ($config->debug > 0);
                        my ($a) = (system("@cmdline > $out 2> $err") >> 8); # 0 if ok
                        if ($a) { # Command failed to execute!
                            print STDERR "Error while trying to execute @cmdline\n";
                            exit 2;
                        }
                        postprocess($config, $library, $out);
                    }
                }
            } # foreach my $database (@{ $config->database })
        } # foreach my $library (sort keys %libraries)
    } # if ($config->_exists('library_search')) {

    return @dispatched;
}

# Check/prepare sequence database format
sub prepare_sequence_database {
    my ($config, $dbname, $progname) = @_;
    my $database_path = $config->database_path;

    die "Missing database_search section in your configuration file!" unless ($config->_exists("database_search"));
    die "Missing database_search section for search program $progname in your configuration file!" unless (exists $config->database_search->{ $progname });

    # Searching for compatible databases
    my $dbexts = $config->database_search->{ $progname };
    $dbexts =~ s/^\s+//; $dbexts =~ s/\s+$//;
    my @dbexts = split(/\s*\,\s*/,$dbexts);
    foreach my $dbext (@dbexts) {
        return fileparse($dbname, $dbext) if ($dbname =~ /$dbext$/ && -r $dbname);
        foreach my $dbpath (".", @{ $database_path }) {
            my @files = grep { m|$dbname$dbext$| && -r $_ } glob("$dbpath/$dbname*");
            return fileparse($files[0], $dbext) if (scalar @files);
        }
    }

    # Special case for system BLAST databases
    if ($progname =~ /^blast/i) {
        my $blastdbcmd = find_executable("blastdbcmd");
        my ($a) = (system("$blastdbcmd -db $dbname -info >> /dev/null 2>&1") >> 8); # 0 if ok
        return ($dbname, undef, undef) unless ($a); # $a is true if blastdbcmd cannot use $dbname BLAST database
    }

    # If no compatible database was found, we can still try to format one for BLAST
    foreach my $dbpath (".", @{ $database_path }) {
        foreach my $ext ("", qw(.fa .faa .fas .fasta .FASTA .FAS)) {
            my $target = "$dbpath/$dbname$ext";
            if (-r $target && $config->_exists("database_format") && exists $config->database_format->{$progname}) {
                my $formatter = $config->database_format->{$progname};
                $formatter =~ s/\<dbname\>/$target/g;
                if ($config->mode eq "test") {
                    print STDERR "$formatter\n";
                    return ($dbname, $dbpath, $ext);
                } elsif ($config->mode eq "run") {
                    my ($a) = (system("$formatter >> /dev/null 2>&1") >> 8); # 0 if ok
                    die "Error while trying to format database with command:\n$formatter" if ($a);
                    return prepare_sequence_database($config, "$dbname$ext", $progname);
                }
            }
        }
    }

    die "Could not find a ${progname}-compatible database named $dbname in your --database_path\n";
}

sub get_nofseqs_from_fasta {
    my ($file) = @_;
    open(FILE,"<$file") || die "Could not open FASTA file $file";
    my $nofseqs = 0;
    while (<FILE>) {
        $nofseqs++ if /^>/;
    }
    close(FILE);
    return $nofseqs;
}

sub get_blastdb_size {
    my ($config, $target) = @_;
    my ($blastdbcmd) = find_executable("blastdbcmd");
    my $dbsize = 100000000;
    return $dbsize unless (defined $blastdbcmd && length $blastdbcmd);
    eval {
        open(DB,"$blastdbcmd -db $target -info |") || do {
            warn "WARNING: blastdbcmd command failed to get size of database $target!!! Loading -b and -v values from the configuration file.";
            return $dbsize;
        };
        while (<DB>) {
            /(\S+) sequences\;/ && do {
                ($dbsize=$1) =~ s/\,//g;
                return $dbsize;
            }
        }
        close(DB);
    };
    if ($@) {
        warn "Failed to retrieve database size using blastdbcmd. Loading -b and -v values from configuration file";
        return $dbsize;
    }
    return $dbsize;
}

sub get_command_line {
    my ($config, $profile, $target) = @_;

    # Load search program options
    my %args = ();
    my $extension = $profile->extension;
    my $progname = $config->profile_search->{$extension};
    %args = %{ $config->get("program_parameter_$progname") } if ($config->_exists("program_parameter_$progname"));

    # Load executable name
    my @cmdline = ($profile->executable); # Program path
    COMMAND: {
        $_ = $progname;

        # HMMER
        /^(hmmsearch|jackhmmer|hmmscan)/io && do {
            my $file = $profile->file;
            if ($extension =~ /^(.h3i|.ssi)$/io) {    # Load HMM from library 
                $file =~ s/\.(h3i|ssi)//;             # Clean library name
                unshift(@cmdline, "|");               # Add pipe
                unshift(@cmdline, $profile->id);      # Profile name
                unshift(@cmdline, $file);             # HMM library
                unshift(@cmdline, $profile->fetcher); # Fetch method
                $file = '-';
            }
            $args{"--cpu"} = number_of_processors() unless (exists $args{"--cpu"} && defined $args{'--cpu'});
            if ($progname =~ /hmmsearch|hmmscan|hmmpfam/ && scalar(grep { defined $_ && /^--cut_(ga|nc|tc)$/ } keys %args)) {
                map { delete $args{$_} } qw(-E -domE -T -domT);
            } elsif (!(exists $args{'-E'} && defined $args{'-E'}) && defined $profile->inclusion_threshold) {
                $args{"-E"} = $profile->inclusion_threshold;
            }
            $args{"-N"} = $profile->number_of_iterations if ($progname =~ /^jackhmmer/ && !(exists $args{'-j'} && defined $args{'-j'}) && defined $profile->number_of_iterations);
            push(@cmdline, %args);                    # Hmmsearch options (set by configuration file)
            push(@cmdline, $file);                    # HMM file
            push(@cmdline, $target);                  # Sequence file
            last COMMAND;
        };

        # PSI-BLAST profile or FASTA file
        /^blast(all|pgp)$/io && do {
            my $query = $profile->file;
            $args{"-a"} = number_of_processors()  unless (exists $args{'-a'} && defined $args{'-a'});
            $args{"-e"} = $profile->maximum_evalue_cutoff unless (exists $args{'-e'} && defined $args{'-e'});
            $args{"-v"} = get_blastdb_size($config, $target);
            $args{"-b"} = get_blastdb_size($config, $target);
            if ($profile->executable =~  /blastpgp$/) {
                $args{"-j"} = $profile->number_of_iterations unless (exists $args{'-j'} && defined $args{'-j'});
                $args{"-h"} = $profile->inclusion_threshold  unless (exists $args{'-h'} && defined $args{'-h'});
                if ($query  =~ s/\.(asn1|chk)$/.csq/) {
                    die "Could not find the query sequence file $query for profile ".$profile->name unless (-f $query);
                    $args{"-q"} = 1 if ($extension eq '.asn1');
                    $args{"-R"} = $profile->file;
                }
            }
            push(@cmdline, %args); # Options
            push(@cmdline, "-i", $query);
            push(@cmdline, "-d", $target) if (defined $target);
            last COMMAND;
        };

        # PSI-BLAST profile or FASTA file
        /^(rps|psi|t)blast$|^blast(p|n|x)?$/io && do {
            my $query = $profile->file;
            $args{"-num_threads"} = number_of_processors()  unless (exists $args{'-num_threads'} && defined $args{'-num_threads'});
            $args{"-evalue"} = $profile->maximum_evalue_cutoff unless (exists $args{'-evalue'} && defined $args{'-evalue'});
	    $args{"-outfmt"} = "'7 saccver qaccver sstart send evalue qcovhsp qstart qend bitscore slen'";
            my ($format) = exists $args{"-outfmt"} ? ($args{"-outfmt"} =~ /\b(\d+)\b/ ? $1 : 0) : 0;
            if ($format <= 4) {
                my $nout = delete $args{"-max_target_seqs"};
                unless (exists $args{'-num_descriptions'} && defined $args{'-num_descriptions'}) {
                    $args{"-num_descriptions"} = defined $nout ? $nout : get_blastdb_size($config, $target);
                }
                unless (exists $args{'-num_alignments'} && defined $args{'-num_alignments'}) {
                    $args{"-num_alignments"} = defined $nout ? $nout : get_blastdb_size($config, $target);
                }
            } elsif (!exists $args{'-max_target_seqs'} || !defined $args{'-max_target_seqs'}) {
                my $nout1 = delete $args{"-num_descriptions"} || 0;
                my $nout2 = delete $args{"-num_alignments"} || 0;
                $args{"-max_target_seqs"} = $nout1 > $nout2 ? $nout1 : $nout2;
                $args{"-max_target_seqs"} = get_blastdb_size($config, $target) if ($args{'-max_target_seqs'} == 0);
            }
            if ($profile->executable =~  /psiblast/) {
                $args{"-num_iterations"} = $profile->number_of_iterations unless (exists $args{'-num_iterations'} && defined $args{'-num_iterations'});
                $args{"-inclusion_ethresh"} = $profile->inclusion_threshold  unless (exists $args{'-inclusion_ethresh'} && defined $args{'-inclusion_ethresh'});
                $args{"-in_pssm"} = $profile->file;
            }
            push(@cmdline, %args); # Options
            push(@cmdline, "-query", $query) unless (exists $args{'-in_pssm'} && defined $args{'-in_pssm'});
            push(@cmdline, "-db", $target) if (defined $target);
            last COMMAND;
        };

        # RPS-BLAST
        /^rpsblast$/i && do {
            $args{"-a"} = number_of_processors() unless (exists $args{'-a'} && defined $args{'-a'});
            if (!defined $args{"-b"} && !defined $args{"-v"}) {
                $args{"-v"} = $args{"-b"} = get_nofseqs_from_fasta($target);
            } elsif ( defined $args{"-b"} && !defined $args{"-v"}) {
                $args{"-v"} = $args{"-b"};
            } elsif (!defined $args{"-b"} &&  defined $args{"-v"}) {
                $args{"-b"} = $args{"-v"};
            }
            push(@cmdline, %args);
            push(@cmdline, "-i", $target);
            push(@cmdline, "-d", $profile->file);
            last COMMAND;
        };
    }

    return @cmdline;
}

# Retrieve command line for library analysis
sub get_library_command_line {
    my ($config, $library, $dbname, $libext) = @_;
    my $progname = $config->library_search->{ $libext };

    # Check if format was defined
    die "Unknown library format $libext for library $library" unless (defined $progname);

    # Find the executable for this profile
    my $executable = find_executable($config->program_path->{$progname} || $progname);
    if (!defined $executable) {
        print STDERR "Could not find executable search tool for library $library ($progname)" if ($config->debug > 1);
        return undef;
    }

    my @cmdline = ($executable);
    my %args = $config->_exists("program_parameter_$progname") ? %{ $config->get("program_parameter_$progname") } : ();
    CMDLINE: {
        $_ = $progname;

        # Old RPS-BLAST
        /^rpsblast_legacy$/i && do {
            $args{"-a"} = number_of_processors() unless (exists $args{'-a'} && defined $args{'-a'});
            if (!defined $args{"-b"} && !defined $args{"-v"}) {
                $args{"-v"} = $args{"-b"} = get_nofseqs_from_fasta($dbname);
            } elsif ( defined $args{"-b"} && !defined $args{"-v"}) {
                $args{"-v"} = $args{"-b"};
            } elsif (!defined $args{"-b"} &&  defined $args{"-v"}) {
                $args{"-b"} = $args{"-v"};
            }
            push(@cmdline, %args);
            push(@cmdline, "-i", $dbname);
            push(@cmdline, "-d", $library);
            last CMDLINE;
        };

        # RPS-BLAST
        /^rpsblast$/i && do {
            $args{"-threads"} = number_of_processors() unless (exists $args{'-a'} && defined $args{'-a'});
            if (!defined $args{"-num_descriptions"} && !defined $args{"-num_alignments"}) {
                $args{"-num_descriptions"} = $args{"-num_alignments"} = get_nofseqs_from_fasta($dbname);
            } elsif ( defined $args{"-num_descriptions"} && !defined $args{"-num_alignments"}) {
                $args{"-num_alignments"} = $args{"-num_descriptions"};
            } elsif (!defined $args{"-num_descriptions"} &&  defined $args{"-num_alignments"}) {
                $args{"-num_descriptions"} = $args{"-num_alignments"};
            }
            push(@cmdline, %args);
            push(@cmdline, "-query", $dbname);
            push(@cmdline, "-db", $library);
            last CMDLINE;
        };

        /^hmmscan/i && do {
            $args{"--cpu"} = number_of_processors() unless (exists $args{'--cpu'} && defined $args{'--cpu'});
        };

        # Generic (works for HMMER)
        push(@cmdline, %args, $library, $dbname);
    }

    return @cmdline;
}

# Run postprocessors
sub postprocess {
    my ($config, $target, $file) = @_;

    # Load paths
    my ($log,$post) = (".",".");
    unless ($config->simple) {
        ($log,$post) = ("log","post");
        mkdir("post") unless (-d "post");
    }

    my %out = ();
    my $stat = -1; # Indicates no post-processor was run
    foreach my $processor (@{ $config->postprocessor }) {
        # Prepare standard output and standard error files
        my $out = basename($file);
        $out =~ s/\.[^\.]+$//;
        (my $name = basename($processor, '.pm')) =~ s/ .*//;
        my $err = "$log/${out}.${name}.err";
        my $output = "$post/${out}.${name}";
        $out{$output}++;
        $output .= "." . $out{$output} if ($out{$output} > 1);

        # Run processors
        if ($processor =~ /\.pm$/) { # Processor is a module
            require $processor;
            $stat = process($config, $target, $file, $output, $err); # Die unless this subroutine exists!
        } else { # Processor is an external program or script
            ($stat) = (system("$processor $file > $output 2> $err") >> 8); # 0 if ok
            if ($stat) { # Processor failed to execute!
                print STDERR "Run of postprocessor $processor failed for batch $out";
                exit 2;
            }
        }
        $file = $output;
    }

    return $stat;
}

sub find_executable {
    my $executable = undef;
    foreach my $name (@_) {
        next unless (defined $name && length $name);
        foreach my $exe (split(/\s*\,\s*/,$name), which($name)) {
            if ( -x $exe ) {
                $executable = $exe;
                last;
            }
        }
    }
    return $executable;
}

# This subroutines uses Application::Config to parse configuration
# parameters. After parsing, it defines two additional hash-based
# options that will never be availbale to the command line:
# _exclude and _include. It finally copies the lists provided by
# options --exclude and --include to these hashes and retuns the
# configuration object 
sub parse_configuration {
    # Loading library
    use Application::Config qw(:argcount :expand GetConfig);

    # find where we are
    use Cwd; # I just leave this here to remind you where getcwd cames from ;)
    my $Cwd = getcwd;
    $ENV{PROFILEDB} = Rotifer::DB::Base->data_path("profiledb") || "$ENV{ROTIFER_DATA}/profiledb";

    # Defining options
    my %hash = (# Configuration parameters
        'annotation' => {
            ALIAS    => "ann",
            ARGCOUNT => ARGCOUNT_LIST,
            DEFAULT  => [ 'default' ],
            SUMMARY  => 'Table(s) of profile annotations',
        },

        'children' => {
            ALIAS    => 'c',
            ARGCOUNT => ARGCOUNT_ONE,
            DEFAULT  => 'all',
            SUMMARY  => "Number of ontology layers to descend while selecting profiles"
        },

        'database' => {
            ALIAS    => "target|hit|d|db",
            ARGCOUNT => ARGCOUNT_LIST,
            DEFAULT  => [ 'default' ],
            SUMMARY  => 'Sequence database to search',
        },

        'database_path' => {
            ALIAS    => "target_path|fadb",
            ARGCOUNT => ARGCOUNT_LIST,
            DEFAULT  => [],
            SUMMARY  => 'path to sequence databases',
        },

        'exclude' => {
            ACTION   => 'EXPAND_FILES', # See perldoc AppConfig::AutoDoc
            ALIAS    => "x",
            ARGCOUNT => ARGCOUNT_LIST,
            DEFAULT  => [],
            SUMMARY  => "List of profiles to exclude"
        },

        'iterations' => {
            ALIAS    => "j",
            ARGCOUNT => ARGCOUNT_ONE,
            DEFAULT  => 3,
            SUMMARY  => "Maximum number of search rounds (overridden by 'iteration' entries in --annotation table)",
        },

        'mode' => {
            ARGCOUNT => ARGCOUNT_ONE,
            DEFAULT  => "run",
            SUMMARY  => "Running mode. Available modes are: run, test and show",
            VALIDATE => '^(run|show|test)$',
        },

        'name' => {
            ALIAS    => "batch|n",
            ARGCOUNT => ARGCOUNT_ONE,
            DEFAULT  => 'runprofiles.<process ID>',
            SUMMARY  => 'Set a name for the output directory tree',
        },

        'ontology_file' => {
            ALIAS    => "ontology|terms|o",
            ARGCOUNT => ARGCOUNT_LIST,
            DEFAULT  => [ 'default' ],
            SUMMARY  => 'Definitions of terms used for profile annotation (based on Bio::OntologyIO)',
        },

        'ontology_format' => {
            ALIAS    => "ontofmt|f",
            ARGCOUNT => ARGCOUNT_ONE,
            DEFAULT  => 'obo',
            SUMMARY  => 'Bio::OntologyIO parser name for ontology files',
        },

        'pcut' => {
            ALIAS    => "evalue|e|p",
            ARGCOUNT => ARGCOUNT_ONE,
            DEFAULT  => 0.01,
            SUMMARY  => 'Post-processor e-value threshold',
        },

        'postprocessor' => {
            ALIAS    => "post",
            ARGCOUNT => ARGCOUNT_LIST,
            DEFAULT  => [ "srch2table.pm" ],
            SUMMARY  => '(list of) commands to process search results',
        },

        'postprocessor_path' => {
            ALIAS    => "postlib",
            ARGCOUNT => ARGCOUNT_LIST,
            DEFAULT  => [ "default" ],
            SUMMARY  => 'path to modules/programs used to process search results',
        },

        'profile_path' => {
            ALIAS    => "query_path",
            ARGCOUNT => ARGCOUNT_LIST,
            DEFAULT  => [ "default" ],
            SUMMARY  => 'List of files/directories with profiles',
        },

        'que' => {
            ALIAS    => "farm",
            ARGCOUNT => ARGCOUNT_NONE,
            DEFAULT  => 0,
            SUMMARY  => 'Parallelize sequence searches in a distributed environment',
        },

        'regexp' => {
            ALIAS    => "r",
            ARGCOUNT => ARGCOUNT_NONE,
            DEFAULT  => 0,
            SUMMARY  => "Enable selection of profiles using PERL regular expressions (BE CAREFUL!)",
        },

        'simple' => {
            ALIAS    => "same_dir|s",
            ARGCOUNT => ARGCOUNT_NONE,
            DEFAULT  => 0,
            SUMMARY => "Save all output files in the current directory, instead of creating an output directory tree",
        },

        'threshold' => {
            ALIAS    => "h",
            ARGCOUNT => ARGCOUNT_ONE,
            DEFAULT  => 0.01,
            SUMMARY  => "Inclusion threshold for all profiles (overridden by 'hcut' entries from --annotation table)",
        },

        # Change AppConfig::AutoDoc pre-defined options
        # Redefining help message aliases to exclude -h option
        'help' => {
            ALIAS => "usage",
        },

        'configfile' => {
            DEFAULT => [ Rotifer->sysdir("etc","runprofiles","runprofiles.conf") ],
        },
    );

    # Parsing command line and configuration files
    my $appconfig = GetConfig({ CASE => 1, EXPECT_INPUT => 1, EXPAND_ARGV => 0,
            CREATE => '^(alias_|program_|profile_fetch|profile_search|library_search|database_search|database_fetch|database_format|postprocessor_param)', 
            GLOBAL => { ARGCOUNT => ARGCOUNT_HASH, EXPAND => EXPAND_ENV },
        }, %hash);

    # Expanding --database: it cannot be done using ACTION -> 'EXPAND_FILES' (see AppConfig::AutoDoc)
    # because we need to know the filename suffixes associated with databases, which are only known 
    # after the configuration file is parsed (parameter database_search), i.e. after ACTION is used.
    &expand_path($appconfig, "database", $appconfig->database, map { s/^\s*//; s/\s*$//; split(/\s*\,\s*/) } values %{ $appconfig->database_search });
    &expand_path($appconfig, "profile" , \@ARGV              , keys %{ $appconfig->profile_search });

    # Inspect @ARGV to process
    #  (1) comma separated lists that need to be split
    # or
    #  (2) TABs separating queries and target databases.
    #
    # Runprofiles provides two ways to specify the queries (profiles) and databases that should
    # searched: a flat list of queries (possibly separated by commas) may be given and will be  
    # compared to all databases listed by option "-d" (see list of options below) or a set of
    # query/database pairs may be specified in one or more text tables with two columns 
    # separated by a TAB. 
    # 
    # In a typical runprofiles search, the list of queries provided in @ARGV is compared to all
    # target databases (-d option). The list of queries may also be provided as text files that
    # should contain one query name per row.
    #
    # When loaded from auto-expanded text files, @ARGV may contain TABs. Such TABs will imply
    # that the input file is describing an execution plan, i.e. defining the set of query
    # and database pairs that should be executed. If any of the elements in @ARGV contain a 
    # TAB, the use of execution plans is activated and the searches based on queries/profiles
    # listed in the execution plan are restricted to the databases listed in the plan.
    #
    # Profiles not listed in at least one execution plan are used in searches against all databases,
    # including databases listed in execution plans.
    #
    # Note that profiles and databases listed in execution plans should contain only their respective
    # names and not full paths or any suffixes. 

    $appconfig->define('_plan' => { ARGCOUNT => ARGCOUNT_HASH, DEFAULT => {} });
    my $plan  = $appconfig->_plan;
    my $dbRef = $appconfig->database;
    my @tmp = @ARGV;
    @ARGV = ();
    foreach my $entry (@tmp) {
        if ($entry =~ /\t/) { # Execution plan entry found!
            my ($query, $database) = split(/\t/, $entry, 2);
            die "You can't use commas in query names when defining execution plans!\nRevise entry '$query'" if ($query =~ /\,/);
            #@{ $appconfig->database } = () if (!scalar(keys %$plan));
            push(@ARGV, $query) unless (exists $plan->{uc $query});
            $database = $appconfig->alias_database->{$database} if (exists $appconfig->alias_database->{$database});
            $database =~ s/\s*\,*\s*$//;
            $database =~ s/^\s*\,*\s*//;
            foreach my $db (split(/\s*\,\s*/, $database)) {
                $plan->{uc $query}{$db} = 1;
                push(@{$dbRef}, $db) unless (grep { $_ eq $db || $_ eq $database } @$dbRef);
            }
        } else {
            $entry =~ s/\s*\,*\s*$//;
            $entry =~ s/^\s*\,*\s*//;
            push(@ARGV, split(/\s*\,\s*/, $entry)); # Split and store
        }
    }

    # Split identifiers in options that accept comma-separated lists
    foreach my $option ($appconfig->get_options) {
        next unless ($appconfig->get_type($option) eq 'array');
        my $optRef = $appconfig->get($option); # Load accessor
        my @tmp = @{ $optRef };                # Copy array
        @{ $optRef } = ();                     # Empty array
        map { s/\s*\,*\s*$//; s/^\s*\,*\s*//; push(@$optRef, split(/\s*\,\s*/)) } @tmp; # Reset and DON'T RUN ACTION
    }

    # Replacing all aliases
    $appconfig->database_path->[0] = 'default' if (!scalar(@{ $appconfig->database_path }) && $appconfig->_exists('alias_database_path') &&
        exists $appconfig->alias_database_path->{'default'});
    my %alias  = $appconfig->varlist("^alias_");
    #my @pAliases = (); # No alias for profile_path? See below...
    #@pAliases = grep { exists $appconfig->alias_profile_path->{$_} } @{ $appconfig->profile_path } if ($appconfig->_exists('alias_profile_path'));
    foreach my $aliasname (keys %alias) {
        (my $name = $aliasname) =~ s/^alias_//;
        my $aliasRef = $alias{$aliasname};
        my $ref = $appconfig->get($name);

        # If we have the same aliases for various options, lets make them equal to profile_path
        #if ($name ne 'database' && $name ne 'profile_path') {
        #    foreach my $palias (@pAliases) {
        #	next if (!exists $aliasRef->{$palias} || grep { /$palias/ } @$ref);
        #	$appconfig->set($name,$palias); # Add profile_path aliases
        #    }
        #}

        if (ref($ref) eq 'ARRAY') {
            for (my $i=0; $i<= $#{$ref}; $i++) {
                next unless (exists $aliasRef->{ $ref->[$i] });
                $ref->[$i] = $aliasRef->{ $ref->[$i] };
            }
        } else {
            $appconfig->set($name, $aliasRef->{$name});
        }
    }

    # Split identifiers in options that accept comma-separated lists again (because we replaced aliases...)
    foreach my $option ($appconfig->get_options) {
        next unless ($appconfig->get_type($option) eq 'array');
        my $optRef = $appconfig->get($option); # Load accessor
        @{ $optRef } = map { s/\s*\,*\s*$//; s/^\s*\,*\s*//; split(/\s*\,\s*/) } @{ $optRef }; # Reset but DON'T RUN ACTION
    }

    # Change relative paths to absolute paths (I guess there is a library which does this...) 
    foreach my $option (qw(annotation database_path profile_path postprocessor_path ontology)) {
        my $ref = $appconfig->get($option);
        for (my $i=0; $i<=$#{$ref}; $i++) {
            if ( -r "./".$ref->[$i] || -d "./".$ref->[$i] ) {
                #$ref->[$i] =~ s/\.\///;
                $ref->[$i] = "$Cwd/".$ref->[$i];
            }
        }
    }

    # Enforce use of database_path alias
    die "You did not define a database path!\nPlease do it using:\n - option --database_path or\n - giving the full path to your target database or\n - setting a 'default' alias for database_path in the section [alias] of you configuration file.\n" unless (scalar @{ $appconfig->database_path });
    die "I can't access (some of) your database path(s) (".join(", ",@{ $appconfig->database_path }).")!\nPlease choose a different directory for your target sequence and BLAST databases using option --database_path." unless (grep { defined && -d } @{ $appconfig->database_path });

    # Set fully qualified path to postprocessors
    $dbRef = $appconfig->postprocessor;
    for (my $i=0; $i<=$#{$dbRef}; $i++) {
        my $path = $dbRef->[$i];
        my @post = split(" ",$path);
        foreach my $lib ($Cwd, @{ $appconfig->postprocessor_path }) {
            if (-f "$lib/$post[0]") {
                $dbRef->[$i] = "$lib/$path";
            } elsif (-f "$lib/${path}.pm") {
                $dbRef->[$i] = "$lib/${path}.pm";
            }
        }
    }

    # Exclusions: copy arguments of --exclude to an internal hash
    $appconfig->define("_exclude" => { ARGCOUNT => ARGCOUNT_HASH, DEFAULT => {} });
    my $exclRef = $appconfig->_exclude;
    map { $exclRef->{ uc($_) } = 1 } @{ $appconfig->exclude };

    # Inclusions: copy @ARGV to an internal hash
    $appconfig->define("_include" => { ARGCOUNT => ARGCOUNT_HASH, DEFAULT => {} });
    $appconfig->define("_include_all" => { ARGCOUNT => ARGCOUNT_NONE, DEFAULT => 0 });
    my $inclRef = $appconfig->_include;
    map { $inclRef->{ uc($_) } = 0; $appconfig->_include_all(1) if (/^all$/io) } @ARGV;

    # Ontologies: deactivating use of ontologies
    foreach my $option (qw(ontology_file annotation)) {
        @{ $appconfig->get($option) } = () if (grep { /^none$/io } @{ $appconfig->get($option) });
    }

    # Translating 'all' to a numeric ontology depth
    $appconfig->set("children", -1) if ($appconfig->children =~ /^all$/i || $appconfig->_include_all);

    # Set running directory
    $appconfig->name("runprofiles.$$") if ($appconfig->name eq 'runprofiles.<process ID>');

    # Since we make a lot of changes to the configuration object after parsing it
    # we need a replacement for AppConfig::AutoDoc's "--debug config" debugging method
    $appconfig->_dump_to_stderr if ($appconfig->debug eq 'postconfig');

    return $appconfig;
}

# We use this instead of ACTION => EXPAND_FILES because we should not expand
# database files but those could be used asa arguments for --database
#
# Separating database path, name and extension is necessary because different profiles
# may need different database formats and programs in searches. The association between
# formats and program is mediated by the database filename suffixes and described in the
# configuration file
sub expand_path {
    my ($conf, $name, $ref, @ext) = @_;
    my $pathRef = $conf->get("${name}_path");
    my $nalias  = $conf->_exists("alias_${name}") ? $conf->get("alias_${name}") : undef;
    my $palias  = $conf->_exists("alias_${name}_path") ? $conf->get("alias_${name}_path") : undef;
    my @tmp     = @$ref;

    @{$ref} = ();
    my %seen = ();
    foreach my $file (@tmp) {
        my @add = ($file);
        if (-f $file && !(grep { $file =~ /$_$/ } @ext)) {
            # Since this file does not match a database filename suffix
            # ir is assumed to contain a list of target databases
            open(FILE,"<$file") || die "Could not open file $file";
            @add = map { chomp; s/^\s+//; s/\s+$//; $_ } <FILE>;
            close(FILE);
        }

        # Separating path from name
        for (my $i=0; $i<=$#add; $i++) {
            my ($basename, $path, $suffix) = fileparse($add[$i], map { $_ = "\\$_" if (/^\./); $_ } @ext);
            if (length $path && -d $path && $basename ne $add[$i]) {
                # Path
                my @real = defined($palias) ? expand_alias($palias, $path) : ($path);
                foreach my $real (@real) {
                    push(@$pathRef, $real) unless (grep { $_ eq $real } @$pathRef);
                }
                $add[$i] = $basename;
            }

            # Name
            my @real = defined($nalias) ? expand_alias($nalias, $add[$i]) : ($add[$i]);
            foreach my $real (@real) {
                next if (exists $seen{$real});
                push(@$ref, $real);
                $seen{ $real } = 1;
            }
        }
    }

    return keys %seen;
}

sub expand_alias {
    my ($aliases, $name) = @_;
    if (exists $aliases->{$name}) {
        return map { s/\s*\,*\s*$//; s/^\s*\,*\s*//; $_ } split(/\s*\,\s*/, $aliases->{$name});
    } else {
        return $name;
    }
}

# Detect number of CPUs
sub number_of_processors {
    my $np = 1;
    if ( -r "/proc/cpuinfo") {
        open(C,"</proc/cpuinfo");
        while (<C>) { 
            chomp;
            /processor\s*:\s*(\d+)/ && do {
                $np = $1;
            }
        }
        close(C);
    }
    $np++;
    $np = int($np/2) if ($np > 1);
    return $np;
}

__END__

# DOCUMENTATION: end
# Documentation (use option -doc or --doc to see it!)
#
# AppConfig::AutoDoc can automatically extract Plain Old Documentation
# from within the caller program's, add descriptions of the options
# created by L<define> and do some pretty formatting for output.
# 
# Note that POD may be added anywhere in your program, thus allowing 
# the documentation for a program to be left side by side with the
# function's definition.

=head1 NAME

 runprofiles - search sequence databases for matches to a library
               of profiles or query sequences

=head1 SYNOPSIS

 # See configuration file runprofiles.conf
 #
 # NOTE: YOU ALWAYS NEED TO NAME THE QUERIES YOU WANT
 #       TO USE (use "all" for all profiles or queries)
 #       READ the section "Input" below
 #
 # Generic format: runprofiles <list of queries>
 #
 # Simplest use case: default options, all profiles

 runprofiles all

 # Using a different profile path

 runprofiles -profile_path NewProfiles all

 # Adding local directory NewProfiles to profile path
 # See definition of 'default' path in runprofiles.conf

 runprofiles -profile_path default --profile_path NewProfiles all

 # Choosing a subset of profiles based on functional category(ies)
 # and setting the target database to data/fadb/prok.fa
 #
 # Read the file pointed by --configfile for the definition
 # of prok (section [alias], entry database_path)

 runprofiles -d prok 'Adhesion, Lipid signaling'

 # Set target database to a local file (newgen.fa) and ignore
 # profiles related to Signaling processes, except PAS

 runprofiles -d newgen.fa -exclude Signaling all PAS

=head1 DESCRIPTION

This program searches sequence databases for matches against libraries
of sequences and/or sequence profiles recognized by programs like BLAST,
PSI-BLAST, RPS-BLAST, HMMER and similar programs.

In runprofiles, the sequences the user wants to analyse are correspond to
the B<hits> or B<sequence databases> (see I<--database_path> and 
I<--database> below), while the profiles or sequences libraries used in
the searches are the B<queries> (see section I<Input>).

=head2 Input

Runprofiles B<WILL DO NOTHING> unless provided a list of queries. The queries are usually
named on the command line, after all the options, but the program actually supports three ways
such a list of queries (profiles) may be defined: 

=over

=item * 

the reserved keyword B<"all">, regardless of case (upper/lower) indicates all profiles
in I<--profile_path> should be used, except for those excluded with I<--exclude>

=item * 

a flat B<list of queries> (possibly separated by commas) may be given, one by one,
as non-option arguments in the command line or as rows in a file named in the command 
line and will be compared to all databases set by option I<--database> (see list of options
below). Example: C<runprofiles -d nr PAS ZDNA-HTH> will search for matches to both PAS and 
ZDNA-HTH profiles in nr.

=item * 

a list of B<query and database pairs> may be specified in one or more text tables
with two columns separated by a TAB. Example: the command C<runprofiles pairs.txt>, where
pairs.txt contains

 PAS      nr
 ZDNA-HTH env_nr

will restrict the searches to running PAS against the nr database and ZDNA-HTH against env_nr. 

=back

In a typical runprofiles search, each query specified in the command line is compared
to all sequence databases. This list of queries may also be provided as text files with
B<one query name per row> (a feature called I<auto-expansion>).

Note that files containing list of queries or pairs of queries and databases B<must not
contain the filename extensions that are used to identify sequence files>. See comments
on filename extensions in the sections L<Profile path> and L<Available sequence databases>
below.

=head3 B<Execution plans from auto-expanded text files: query/database pairs>

When loaded from auto-expanded text files, @ARGV may contain TABs. Such TABs will imply
that the input file is describing an execution plan, i.e. defining the set of query
and database pairs that should be executed. If any of the elements in @ARGV contain a 
TAB, the use of execution plans is activated and the searches based on queries or 
profiles listed in the execution plan are restricted to the databases specified by the
execution plan. All other queries and databases are compared to all databases, including
the ones listed by execution plans.

=head2 Profile selection

The list of profiles or queries that are to be included in one analysis
is simply given in the command line before, after or between program 
options and their arguments. Alternatively, a file listing pairs of 
profiles and/or query sequences and target databases may be given as a
text file with two columns separated by YABs (see the previous section
comment on auto-expanded input text files).

Additionally, runprofiles suppor The --exclude option which enables the
user to perform complex topological queries based on the ontology files
which contain the profile classifications. This option allow the user to
choose which or which sets of profiles to search against the target 
sequence databases.

Both options accept a comma separated list of profile or domain names
or associated annotations in the command line or the name of files
containing these identifiers, one in each row (i.e. separated by
newlines) or separated by commas.

=head2 Running modes

The program supports different running modes, that the user may set with
option --mode. Most of the modes are intended fo testing the program 
parameters, e.g. to evaluate a selection of profiles (queries) and 
databases before actually running an analysis.

Available running modes are:

=over

=item run  => run the analysis

=item show => print information on the profiles you selected

=item test => show what commands would be issued but do nothing

=back

=head2 Configuration file

Runprofiles requires the presence of a default configuration file in
etc/rotifer/runprofiles.conf. This file should be used to 
define convenient aliases for frequently used sequence databases,
like the default database alias. Environment variables may be used
in this file but their names should be placed between brackets, e.g.
${HOME} to indicate the users home directory (see AppConfig::State).

Some configuration settings are although not obligatory, including
the association of profile filename extensions to the corresponding
search programs and the name and/or installed path of external 
programs including qsub, NCBI's makeblastdb and blastdbcmd and
search programs like HMMER, BLAST, etc.

See more details and comments in the example configuration files 
distributed with runprofiles.

=head2 Profile path

The --profiles_path option defines the location of the user's sequence 
model libraries. This option must be set to a list of directories or 
files containing the sequences and/or profiles that must be used as
queries in the search for homologs. The directories may contain any 
number and levels of subdirectories but the files should be named 
after the supported file name extensions that are defined in the 
configuration file(s) (section [profile], entries search).

=head2 Available sequence databases (--database_path)

When using runprofiles, one is always aiming at performing searches with
some type of query (sequence profiles or sequences in your --profile_path)
against one or more sequence databases, which we call L<target sequences>.

To set the location of target databases, one must use the option
--database_path. This option will take as arguments the path to a directory
where your sequence files, like FASTA files and BLAST databases, are located.
Execution is aborted if the program can't read this directory. 

Since different programs may depend on different sequence file formats, 
sequence database names should contain filename extensions that enables
runprofiles to select the correct database format for each search program.
Filename extensions for each program are defined in the configuration file
in the section L<[database]> using the keyword L<search>. For example,
the entry

 [database]
 search blastpgp = .psq, .fa.psq

would enable use of any files whose names end in .psq or .fa.psq as databases
for blastpgp and the user should specify the database name without the filename
extension (i.e. database "human.psq" would be referred to as "human").

=head2 Associated annotations

Runprofiles supports association of arbitrary annotations to profiles.
The mapping of profiles to annotations is provided in a TAB-separated 
table and the annotation is validated against a controled vocabulary
(ontology).

=head3 Ontologies

Valid annotations are derived from one or more ontology files (specified
with the option --ontology). Such ontologies are used to control both 
what the types of annotations and, in some circunstances, the values 
associated with such annotations. The current implementation can load
ontologies in any format supported by Bio::OntologyIO.

Note: the mandatory Sequence Model Ontology is bundled with the Rotifer
package and should be placed in 

 lib/rotifer/runprofiles/SequenceModel.obo

=head3 Profile annotations

Annotations should be provided as one or more text tables, using option
--annotation. These files should be plain text tables with columns
separated by TABs, whithout any header and should only contain the 
following columns:

   Column  :        Description            : Example
           :                               :
 ProfileID : profile identifier            : CheB-Methylesterase.1
 Type      : annotation type               : iterations
 Value     : annotation value              : 2
 Start     : start of the annotated region : 
 End       : end of the annotated region   : 

The type column above can only contain valid terms, derived from
the Sequence Model Ontology. Check what are the default ontology
files in the standard configuration file (option --configfile, see
below).

The last two columns are optional but allow the userr to identify to
what region of a sequence model the annotation is valid.

For an example of a supported profile annotation table read the 
default annotation file indicated in the program's configuration
file (see default configuration file path below).

=head1 AUTHORS

 Robson Francisco de Souza

=cut
# DOCUMENTATION: end
