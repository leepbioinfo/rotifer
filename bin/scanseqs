#!/bin/bash

#========================================================================
# Defaults
#========================================================================
export EVALUE=0.0101
export CLUSTER=mmseqs
declare -a MERGE=(phobius)
declare -a SIGNATURES=(
	phobius=phobius
	aravind=rpsblast:${DATABASES:-/databases}/profiledb/rpsdb/allprofiles
	aravind=hmmscan:${DATABASES:-/databases}/profiledb/hmmdb/aravindDB.hmm
	pfam=hmmscan:${DATABASES:-/databases}/pfam/Pfam-A.hmm
)

#========================================================================
# Auxiliary functions 
#========================================================================
parseSignaturesDB() {
	local spec=$1
	local name=$(echo $spec | cut -f 1 -d =)
        local software=$(echo $spec | cut -f 2 -d =)
       	local db=$(echo $software | cut -f 2 -d :)
	local software=$(echo $software | cut -f 1 -d :)
	declare -a signature=("$name" "$software" "$db")
	echo "${signature[@]}"
}

isinArray() {
	local t=$1
	shift
	for x in "$@"
	do
		if [ "$x" == "$t" ]; then
			return 0
		fi
	done
	return 1
}

#========================================================================
# Help
#========================================================================
usage() {
	echo "****************** scanseqs (version: 0.1) ******************
Copyright (C) 2024 Robson Francisco de Souza (rfsouza@usp.br)
*************************************************************
This script runs sequence similarity clustering routines and
pattern recognition softwares, such as hmmscan, on biological
sequences.

Usage: $0 [options] <output basename> <sequence file>
Available options:
  Option     : Description                                : Default
-------------:--------------------------------------------:---------
 -e <float>  : minimum e-value for signature detection    : $EVALUE
 -c <string> : similarity clustering pipeline             : $CLUSTER
 -m <string> : signatures to merge to all other signatures: ${MERGE[@]}
 -s <string> : signature detection software and databases : see help
 -h          : print this message                         :

The '-c' option accepts the following clustering methods:
 Method  : Description
---------:---------------------------------------------------
 mmseqs  : MMseqs2 with 100%, 70% and 0% identity thresholds
 none    : disable clustering

For the '-s' option use '$0 -s help' to see the list of available
signature detection softwares and databases and the syntax to add
more pipelines.
"
	exit 1
}

helpSignatures() {
	echo "****************** scanseqs (version: 0.1) ******************
Copyright (C) 2024 Robson Francisco de Souza (rfsouza@usp.br)
*************************************************************
Option '-s' adds signature detection softwares and databases

Usage:
$0 -s <name>=<software>:<database path> <target> <sequence file>

Example:
Adding a custom HMM database from the current directory.

$0 -s mydb=hmmscan:./mymodels.hmm

The <name> argument will be used as part of the names of all
output files generated by that option.

Currently, 'scanseqs -s' supports the following softwares:
hmmscan, rpsblast and phobius.

For softwares that donÂ´t use a database, such as Phobius,
the software name is enough:

$0 -s phobius=phobius

The special argument 'none' disable all pattern recognition
methods and maybe used to reset the defaults. For example,
to restrict our analysis to the Pfam database, use:

$0 -s none -s pfam=hmmscan:/databases/fadb/nr/nr50

Note: whenever two signature detection methods have the
same name (e.g. aravind), results from equally named
analysis will be merged in *.scan.arch files.

Current list of softwares and databases:"
	(
		echo "Name : Software : Path"
		for s in "${SIGNATURES[@]}"
		do
			echo $(parseSignaturesDB "$s")
		done | sed 's/ / : /g'
	) | column -t -s " "
	exit 1
}

#========================================================================
# Command line parser
#========================================================================
OPTERR=0
while getopts "c:e:m:s:" opt
do
    case "$opt" in
	c)
	    CLUSTER_PIPELINE="$OPTARG"
	    ;;
	e)
	    EVALUE="$OPTARG"
	    ;;
	m)
	    if [ "$OPTARG" == "none" ]; then
		    SIGNATURES=()
	    else
		    SIGNATURES+=($OPTARG)
	    fi
	    ;;
	s)
	    if [ "$OPTARG" == "help" ]; then
		    helpSignatures
	    elif [ "$OPTARG" == "none" ]; then
		    SIGNATURES=()
	    else
		    SIGNATURES+=($OPTARG)
	    fi
	    ;;
	*)
	    usage
	    ;;
    esac
done
shift $((OPTIND-1))
OPTIND=0
OPTERR=1

#========================================================================
# Pipelines
#========================================================================
runmmseqs() {
	local target=$1
	local input=$2
	local program=mmseqs
	local out=${target}.c100i100.fa
	local tsv=${target}.c80i0_cluster.tsv
	if [ -f ${out} ]; then
		echo "WARNING: using previously saved results for target ${target} and program ${program}." 1>&2
		echo ${out}
		return
	fi
	mmseqs easy-linclust ${input} ${target}.c100i100 tmp --add-self-matches 1 --min-seq-id 1 -c 1 --threads 36 > ${target}.c100i100.log 2>&1
	mmseqs easy-cluster ${target}.c100i100_rep_seq.fasta ${target}.c80i70 tmp --add-self-matches 1 --min-seq-id 0.7 -c 0.8 --threads 36 > ${target}.c80i70.log 2>&1
	mmseqs easy-cluster ${target}.c80i70_rep_seq.fasta ${target}.c80i0 tmp --add-self-matches 1 --min-seq-id 0 -c 0.8 --threads 36 > ${target}.c80i0.log 2>&1
	for suffix in c100i100 c80i70 c80i0
	do
		ln -s ${target}.${suffix}_cluster.tsv ${target}.${suffix}.tsv
		ln -s ${target}.${suffix}_rep_seq.fasta ${target}.${suffix}.fa
	done
	# Backward compatibility
	ln -s ${target}.c80i0_cluster.tsv ${target}.c80e3.tsv
	rm -fr tmp
}

runhmmscan() {
	local target=$1
	local name=$2
	local input=$3
	local database=$4
	local program=hmmscan
	local out=${target}.${name}.${program}.out
	local err=${target}.${name}.${program}.err
	local tsv=${target}.${name}.${program}.tsv 
	if [ -f ${tsv} ]; then
		echo "WARNING: using previously saved results for target ${target}, program ${program} and database ${database}." 1>&2
		echo ${tsv}
		return
	fi
	cut -f1 -d " " ${input} | parallel --pipe -N1 -j${THREADS:-36} --recstart '>' ${program} --cpu 1 ${database} - > ${out} 2> ${err}
	hmmer2table ${out} > ${tsv}
	echo ${tsv}
}

runhmmsearch() {
	local target=$1
	local name=$2
	local input=$3
	local database=$4
	local program=hmmsearch
	local out=${target}.${name}.${program}.out
	local err=${target}.${name}.${program}.err
	local tsv=${target}.${name}.${program}.tsv 
	if [ -f ${tsv} ]; then
		echo "WARNING: using previously saved results for target ${target}, program ${program} and database ${database}." 1>&2
		echo ${tsv}
		return
	fi
	cat ${database} | parallel --pipe -N1 -j${THREADS:-36} --recstart '^HMMER' ${program} --cpu 4 - ${input} > ${out} 2> ${err}
	hmmer2table ${out} > ${tsv}
	echo ${tsv}
}

runrpsblast() {
	local target=$1
	local name=$2
	local input=$3
	local database=$4
	local program=rpsblast
	local out=${target}.${name}.${program}.out
	local err=${target}.${name}.${program}.err
	local tsv=${target}.${name}.${program}.tsv 
	if [ -f ${tsv} ]; then
		echo "WARNING: using previously saved results for target ${target}, program ${program} and database ${database}." 1>&2
		echo ${tsv}
		return
	fi
	cut -f1 -d " " ${input} | parallel -N1 -j${THREADS:-36} --pipe --recstart '>' ${program} -db ${database} > ${out} 2> ${err}
	cat ${out} | parallel -N1 -j36 --pipe --recstart RPSBLAST blast2table -s > ${tsv}
	echo ${tsv}
}

runpsiblast() {
	local target="$1"
	local name=$2
	local input="$3"
	local program=psiblast
	local out=${target}.${name}.${program}.out
	local err=${target}.${name}.${program}.err
	local tsv=${target}.${name}.${program}.tsv 
	if [ -f ${tsv} ]; then
		echo "WARNING: using previously saved results for target ${target} and program ${program}." 1>&2
		echo ${tsv}
		return
	fi
	${program} -db ${database} -query ${input} -out ${out} -num_alignments ${RESULTS} -num_descriptions ${RESULTS} \
	 -inclusion_ethresh ${THRESHOLD} -num_threads ${THREADS:-8} -parse_deflines -seg no -matrix BLOSUM62 -comp_based_stats 2
	cat ${out} | parallel -N1 -j36 --pipe --recstart PSIBLAST blast2table > ${tsv}
	echo ${tsv}
}

runphobius() {
	local target="$1"
	local name=$2
	local input="$3"
	local program=phobius
	local out=${target}.${name}.${program}.out
	local err=${target}.${name}.${program}.err
	local tsv=${target}.${name}.${program}.tsv 
	if [ -f ${tsv} ]; then
		echo "WARNING: using previously saved results for target ${target} and program ${program}." 1>&2
		echo ${tsv}
		return
	fi
	cut -f1 -d " " ${input} \
	| awk '{if(!/>/){gsub("[BJOUZ_.]","X",$_)};print}' \
	| parallel -N1 -j10 --pipe --recstart ">" ${program} > ${out} 2> ${err}
	phobius2table -e $EVALUE ${out} > ${tsv}
	echo ${tsv}
}

#========================================================================
# Main program
#========================================================================

# Input
target=$1
input=$2
if [ "$target" == "" ] || [ "$input" == "" ] || [ ! -f "$input" ]; then
	usage
fi

# Clustering
if [ "$CLUSTER" != "none" ]; then
	runmmseqs ${target} ${input}
fi

# Change input for sequence signature routines
if [ -f ${target}.c100i100.fa ]; then
	input=${target}.c100i100.fa
fi

# Detecting sequence signatures in all proteins
declare -a merge=()
declare -A other
for spec in "${SIGNATURES[@]}"
do
	declare -a pipeline=($(parseSignaturesDB "${spec}"))
	run="run${pipeline[1]}"
	if declare -F ${run} > /dev/null; then
		output=$(${run} ${target} ${pipeline[0]} ${input} ${pipeline[2]})
		if isinArray "${pipeline[0]}" "${MERGE[@]}"; then
			merge+=("$output")
		else
			other[${pipeline[0]}]="${other[${pipeline[0]}]} $output"
		fi
	else
		echo "WARNING: unsupported software ${pipeline[1]}. Ignoring..."
	fi
done

# Merging results and building architectures
for name in ${!other[@]}
do
	domain2architecture -e $EVALUE ${merge[@]} ${other[$name]} > ${target}.${name}.scan.arch
	architecture2table ${target}.${name}.scan.arch > ${target}.${name}.scan.arch.tsv
done

# Main output files
#ls *.tsv *arch
