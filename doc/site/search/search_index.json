{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Rotifer tools 1.1 Retrieving neighborhood with Rneighbors 1.1.1 Simple Usage 1.2 Retrieving neighborhood with acc2operon 1.2.1 Simple Usage 1.3 Rnexplorer 1.3.1 Simple Usage 1.4 Mcube 1.4.1 Simple Usage 1.5 pfetch 1.5.1 Simple Usage 1.6 phmmscan 1.6.1 Simple Usage 1.7 rlineage 1.7.1 Simple Usage 1.8 uniprot2gi 1.8.1 Simple Usage 1.9 PaperBlast 1.9.1 Simple Usage 2. Modules 2.1 The core module 2.2 Tools module 2.3 Neighborhood module","title":"Rotifer"},{"location":"#rotifer-tools","text":"","title":"Rotifer tools"},{"location":"#11-retrieving-neighborhood-with-rneighbors","text":"","title":"1.1 Retrieving neighborhood with Rneighbors"},{"location":"#111-simple-usage","text":"","title":"1.1.1 Simple Usage"},{"location":"#12-retrieving-neighborhood-with-acc2operon","text":"","title":"1.2 Retrieving neighborhood with acc2operon"},{"location":"#121-simple-usage","text":"","title":"1.2.1 Simple Usage"},{"location":"#13-rnexplorer","text":"","title":"1.3 Rnexplorer"},{"location":"#131-simple-usage","text":"","title":"1.3.1 Simple Usage"},{"location":"#14-mcube","text":"","title":"1.4 Mcube"},{"location":"#141-simple-usage","text":"","title":"1.4.1 Simple Usage"},{"location":"#15-pfetch","text":"","title":"1.5 pfetch"},{"location":"#151-simple-usage","text":"","title":"1.5.1 Simple Usage"},{"location":"#16-phmmscan","text":"","title":"1.6 phmmscan"},{"location":"#161-simple-usage","text":"","title":"1.6.1 Simple Usage"},{"location":"#17-rlineage","text":"","title":"1.7 rlineage"},{"location":"#171-simple-usage","text":"","title":"1.7.1 Simple Usage"},{"location":"#18-uniprot2gi","text":"","title":"1.8 uniprot2gi"},{"location":"#181-simple-usage","text":"","title":"1.8.1 Simple Usage"},{"location":"#19-paperblast","text":"","title":"1.9 PaperBlast"},{"location":"#191-simple-usage","text":"","title":"1.9.1 Simple Usage"},{"location":"#2-modules","text":"","title":"2. Modules"},{"location":"#21-the-core-module","text":"","title":"2.1 The core module"},{"location":"#22-tools-module","text":"","title":"2.2 Tools module"},{"location":"#23-neighborhood-module","text":"","title":"2.3 Neighborhood module"},{"location":"modules/","text":"1. Modules 1.1 The core command-line interface 2.1 Retrieving neighborhood with Rneighbors 2.1.1 Simple Usage 2.2 Retrieving neighborhood with acc2operon 2.2.2 Simple Usage 2.3 Rnexplorer 2.2.3 Simple Usage","title":"Home"},{"location":"modules/#1-modules","text":"","title":"1. Modules"},{"location":"modules/#11-the-core-command-line-interface","text":"","title":"1.1 The core command-line interface"},{"location":"modules/#21-retrieving-neighborhood-with-rneighbors","text":"","title":"2.1 Retrieving neighborhood with Rneighbors"},{"location":"modules/#211-simple-usage","text":"","title":"2.1.1 Simple Usage"},{"location":"modules/#22-retrieving-neighborhood-with-acc2operon","text":"","title":"2.2 Retrieving neighborhood with acc2operon"},{"location":"modules/#222-simple-usage","text":"","title":"2.2.2 Simple Usage"},{"location":"modules/#23-rnexplorer","text":"","title":"2.3 Rnexplorer"},{"location":"modules/#223-simple-usage","text":"","title":"2.2.3 Simple Usage"},{"location":"modules/mymoduleshelp/","text":"","title":"Mymoduleshelp"},{"location":"modules/mymodulesusage/","text":"","title":"Mymodulesusage"},{"location":"modules/core/","text":"The core module Rotifer package containing core functions and classes. Command-line interface (CLI) A package to create core command-line interface.","title":"Content"},{"location":"modules/core/#the-core-module","text":"Rotifer package containing core functions and classes.","title":"The core module"},{"location":"modules/core/#command-line-interface-cli","text":"A package to create core command-line interface.","title":"Command-line interface (CLI)"},{"location":"modules/core/cli/","text":"Command-line interface package This package allow you to create a complete command-line interface. Simple usage: The simplest usage of this package is the following: # The first 3 lines the rotifer module path import os import sys sys.insert(0, '/home/kaihami/mymodules') # Importing the corecli package import rotifer.core.cli as corecli # Allow shell autocomplete import argcomplete __version__ = 0.01 __authors__ = 'Author1; Author2' def parse_cli: # Create multiple argument parser parser = corecli.parser() parser.add_argument('--foo') # Add your arguments here # Add version control parser.add_argument('--version', action = 'version', version = __version__, authors = __authors__, program = os.path.basename(__file__), description = 'A small description' ) # Add configdump, configfile and fun parser2 = corecli.config().input() parser_merged = corecli.merge_parser( parents = [parser, parser2]) # Merge all parsers in one argcomplete.autocomplete(parser_merged) # Allow tab autocomplete args = corecli.parseargs(parser_merged) return args Actions: Default actions: Argparse offers a variety of default actions. The most important actions are covered here, for more information please check argparse manual. append : This action stores a list, and append an argument to the list. import rotifer.core.cli as corecli parser = corecli.parser() parser.add_argument('--mylist', action = 'append') parser.parse_arg('--mylist apple --mylist banana') >> Namespace(mylist=['apple', 'banana']) count This action count the number of times a keyword occurred. Usefull for verbose control. import rotifer.core.cli as corecli parser = corecli.parser() parser.add_argument('-v', '--verbose' action = 'count') If the user pass in the command-line -v or --verbose it will count +1. The user can use -v -v or -vv both will result in verbose = 2. Custom actions: There are two custom actions, the autoload and autoopen described below. autoload This action open and load a file in the memory returning a list of strings. Also, this action can remove (or not) duplicated lines in the file (non-redundant accession for example) and accepts pipe ( '|' ) from the command-line. To remove duplicated lines (default) set duplicates = False . To keep duplicated lines set duplicates = True . One important behaviour when duplicates = False is that the original order is not the same as the input. Usually this action is used with nargs = '*' as showed in the example below. Example: Removing duplicated lines. For example, to remove duplicated accessions from a file import rotifer.core.cli as corecli def parse_cli(): # Create an argument parser parser = corecli.parser() # Add argument with autoload action parser.add_argument('accessions', action = corecli.autoload, nargs = '*') args = corecli.parseargs(parser) return args if __name__ == '__main__': args = parse_cli() print(args.accessions) Keep duplicated lines in the file. For example, when reading a fasta file (each line is an element in the list). import rotifer.core.cli as corecli def parse_cli(): # Create an argument parser parser = corecli.parser() # Add argument with autoload action parser.add_argument('fasta', nargs = '*', action = corecli.autoload, duplicates = False, ) args = corecli.parseargs(parser) return args if __name__ == '__main__': args = parse_cli() print(args.fasta) autoopen TODO Functions: parser Add a argument parser This function substitutes argparse.ArgumentParser(). If you decide to use this function there is no need to import argparse in the program. The add_help is set to False. This is handy if you use corecli.merge_parser (see above). def parser(description = None): return argparse.ArgumentParser(add_help = False, description = description, formatter_class = argparse.RawTextHelpFormatter) Usage example: import rotifer.core.cli as corecli parser = corecli.parser() parser.add_argument(--foo) # same syntax as argparse ... merge_parser This function merge multiple parsers in one. For example, with this function is possible to merge a custom parser with the core parser (containing configfile, configdump and fun). import rotifer.core.cli as corecli def parse_cli: # Create multiple argument parser parser = corecli.parser() parser.add_argument('--foo') # Add your arguments here # Add configdump, configfile and fun parser2 = corecli.config().input() # A new parser parser3 = corecli.parser() parser3.add_argument('--bar') parser_merged = corecli.merge_parser( parents = [parser, parser2, parser3]) # Merge all parsers in one args = corecli.parseargs(parser_merged) return args In this example, three parsers were created: parser, parser2, and parser3. The arguments were merged using merge_parser() function. Usually this function is usefull to merge the rotifer cli with a program specific parser (see Simple Usage ) parseargs This function parse the arguments, it is important to use this function if configdump/configfile is present. It will dump/update the values. You can exclude arguments to be not present in the config file, usually a user input file. This is possible using exclude_from_dump option, the input is a list with argument to exclude. Example: import rotifer.core.cli as corecli def parse_cli(): # Create an argument parser parser = corecli.parser() # Add argument with autoload action parser.add_argument('accessions', action = corecli.autoload, nargs = '*') parser2 = corecli.config().input() parser_merged = corecli.merge_parser(parents = [parser, parser2]) args = corecli.parseargs(parser, exclude_from_dump = ['accessions']) return args if __name__ == '__main__': args = parse_cli() ... A fun option In the corecli.config().input() there is a hidden option called fun. To activate this flag the user should input myscript --fun . This will turn args.fun == True and you can print to the user two outputs (fun or nofun). Usually if the programs finished with no errors you can print the fun message, otherwise the nofun message. A simple case of fun or nofun is the following import sys import rotifer.core.cli as corecli def parse_cli(): # Create an argument parser parser = corecli.parser() # Add argument with autoload action parser.add_argument('accessions', action = corecli.autoload, nargs = '*') parser2 = corecli.config().input() parser_merged = corecli.merge_parser(parents = [parser, parser2]) args = corecli.parseargs(parser, exclude_from_dump = ['accessions']) return args if __name__ == '__main__': args = parse_cli() try: # Long program # finished everything if args.fun: sys.stderr.write(args.fun.fun) except ...: # Catch some error if args.fun: sys.stderr.write(args.fun.nofun)","title":"CLI"},{"location":"modules/core/cli/#command-line-interface-package","text":"This package allow you to create a complete command-line interface.","title":"Command-line interface package"},{"location":"modules/core/cli/#simple-usage","text":"The simplest usage of this package is the following: # The first 3 lines the rotifer module path import os import sys sys.insert(0, '/home/kaihami/mymodules') # Importing the corecli package import rotifer.core.cli as corecli # Allow shell autocomplete import argcomplete __version__ = 0.01 __authors__ = 'Author1; Author2' def parse_cli: # Create multiple argument parser parser = corecli.parser() parser.add_argument('--foo') # Add your arguments here # Add version control parser.add_argument('--version', action = 'version', version = __version__, authors = __authors__, program = os.path.basename(__file__), description = 'A small description' ) # Add configdump, configfile and fun parser2 = corecli.config().input() parser_merged = corecli.merge_parser( parents = [parser, parser2]) # Merge all parsers in one argcomplete.autocomplete(parser_merged) # Allow tab autocomplete args = corecli.parseargs(parser_merged) return args","title":"Simple usage:"},{"location":"modules/core/cli/#actions","text":"","title":"Actions:"},{"location":"modules/core/cli/#default-actions","text":"Argparse offers a variety of default actions. The most important actions are covered here, for more information please check argparse manual.","title":"Default actions:"},{"location":"modules/core/cli/#append","text":"This action stores a list, and append an argument to the list. import rotifer.core.cli as corecli parser = corecli.parser() parser.add_argument('--mylist', action = 'append') parser.parse_arg('--mylist apple --mylist banana') >> Namespace(mylist=['apple', 'banana'])","title":"append:"},{"location":"modules/core/cli/#count","text":"This action count the number of times a keyword occurred. Usefull for verbose control. import rotifer.core.cli as corecli parser = corecli.parser() parser.add_argument('-v', '--verbose' action = 'count') If the user pass in the command-line -v or --verbose it will count +1. The user can use -v -v or -vv both will result in verbose = 2.","title":"count"},{"location":"modules/core/cli/#custom-actions","text":"There are two custom actions, the autoload and autoopen described below.","title":"Custom actions:"},{"location":"modules/core/cli/#autoload","text":"This action open and load a file in the memory returning a list of strings. Also, this action can remove (or not) duplicated lines in the file (non-redundant accession for example) and accepts pipe ( '|' ) from the command-line. To remove duplicated lines (default) set duplicates = False . To keep duplicated lines set duplicates = True . One important behaviour when duplicates = False is that the original order is not the same as the input. Usually this action is used with nargs = '*' as showed in the example below. Example: Removing duplicated lines. For example, to remove duplicated accessions from a file import rotifer.core.cli as corecli def parse_cli(): # Create an argument parser parser = corecli.parser() # Add argument with autoload action parser.add_argument('accessions', action = corecli.autoload, nargs = '*') args = corecli.parseargs(parser) return args if __name__ == '__main__': args = parse_cli() print(args.accessions) Keep duplicated lines in the file. For example, when reading a fasta file (each line is an element in the list). import rotifer.core.cli as corecli def parse_cli(): # Create an argument parser parser = corecli.parser() # Add argument with autoload action parser.add_argument('fasta', nargs = '*', action = corecli.autoload, duplicates = False, ) args = corecli.parseargs(parser) return args if __name__ == '__main__': args = parse_cli() print(args.fasta)","title":"autoload"},{"location":"modules/core/cli/#autoopen","text":"TODO","title":"autoopen"},{"location":"modules/core/cli/#functions","text":"","title":"Functions:"},{"location":"modules/core/cli/#parser","text":"Add a argument parser This function substitutes argparse.ArgumentParser(). If you decide to use this function there is no need to import argparse in the program. The add_help is set to False. This is handy if you use corecli.merge_parser (see above). def parser(description = None): return argparse.ArgumentParser(add_help = False, description = description, formatter_class = argparse.RawTextHelpFormatter) Usage example: import rotifer.core.cli as corecli parser = corecli.parser() parser.add_argument(--foo) # same syntax as argparse ...","title":"parser"},{"location":"modules/core/cli/#merge_parser","text":"This function merge multiple parsers in one. For example, with this function is possible to merge a custom parser with the core parser (containing configfile, configdump and fun). import rotifer.core.cli as corecli def parse_cli: # Create multiple argument parser parser = corecli.parser() parser.add_argument('--foo') # Add your arguments here # Add configdump, configfile and fun parser2 = corecli.config().input() # A new parser parser3 = corecli.parser() parser3.add_argument('--bar') parser_merged = corecli.merge_parser( parents = [parser, parser2, parser3]) # Merge all parsers in one args = corecli.parseargs(parser_merged) return args In this example, three parsers were created: parser, parser2, and parser3. The arguments were merged using merge_parser() function. Usually this function is usefull to merge the rotifer cli with a program specific parser (see Simple Usage )","title":"merge_parser"},{"location":"modules/core/cli/#parseargs","text":"This function parse the arguments, it is important to use this function if configdump/configfile is present. It will dump/update the values. You can exclude arguments to be not present in the config file, usually a user input file. This is possible using exclude_from_dump option, the input is a list with argument to exclude. Example: import rotifer.core.cli as corecli def parse_cli(): # Create an argument parser parser = corecli.parser() # Add argument with autoload action parser.add_argument('accessions', action = corecli.autoload, nargs = '*') parser2 = corecli.config().input() parser_merged = corecli.merge_parser(parents = [parser, parser2]) args = corecli.parseargs(parser, exclude_from_dump = ['accessions']) return args if __name__ == '__main__': args = parse_cli() ...","title":"parseargs"},{"location":"modules/core/cli/#a-fun-option","text":"In the corecli.config().input() there is a hidden option called fun. To activate this flag the user should input myscript --fun . This will turn args.fun == True and you can print to the user two outputs (fun or nofun). Usually if the programs finished with no errors you can print the fun message, otherwise the nofun message. A simple case of fun or nofun is the following import sys import rotifer.core.cli as corecli def parse_cli(): # Create an argument parser parser = corecli.parser() # Add argument with autoload action parser.add_argument('accessions', action = corecli.autoload, nargs = '*') parser2 = corecli.config().input() parser_merged = corecli.merge_parser(parents = [parser, parser2]) args = corecli.parseargs(parser, exclude_from_dump = ['accessions']) return args if __name__ == '__main__': args = parse_cli() try: # Long program # finished everything if args.fun: sys.stderr.write(args.fun.fun) except ...: # Catch some error if args.fun: sys.stderr.write(args.fun.nofun)","title":"A fun option"},{"location":"modules/core/functions/","text":"Core functions package This package contains the core rotifer functions including: - vmsg (verbose message) - dotdict (dot annotation for dictionaries) vmsg Output a verbose message. This function also adds date and time to the message. The simplest case is: import rotifer.core.functions as cf if verbose: cf.vmsg('Simple test') >> ## [12/03/18 10:36:54] Simple test More complex usage includes passing a list of one or more elements. If a list with one element is passed, the output message will behave the same as passing a string Example: import rotifer.core.functions as cf cf.vmsg(['Simple test']) >> ## [12/03/18 10:36:54] Simple test If a list with more than one element is passed, each element is printed in one line. Please note that the first line will contain the time log, subsequent lines will be printed with three '#'. Example import rotifer.core.functions as cf cf.vmsg(['Complex test', 'line1', 'line2']) >> ## [12/03/18 10:36:54] Simple test >> ### line1 >> ### line2 dotdict This is a silly class to access dictionary attributes using dot annotation. Common dictionary usage in python uses, dict['KEY'] to access the value. Using this class you can access the attribute using dot (.), as dict.KEY. It may be usefull to save some typing or sometimes is very handy to use this type of annotation. Example: import rotifer.core.functions as cf cf.dotdict({'apple': 0, 'banana':10, 'orange':20}) print(cf.apple) >> 0 Modifying values import rotifer.core.functions as cf cf.dotdict({'apple': 0, 'banana':10, 'orange':20}) cf.apple = 3 print(cf.apple) >> 3 Passing a dict import rotifer.core.functions as cf common_dictionary = {'apple': 0, 'banana':10, 'orange':20} cf.dotdict(common_dictionary) print(cf.apple) >> 0","title":"Functions"},{"location":"modules/core/functions/#core-functions-package","text":"This package contains the core rotifer functions including: - vmsg (verbose message) - dotdict (dot annotation for dictionaries)","title":"Core functions package"},{"location":"modules/core/functions/#vmsg","text":"Output a verbose message. This function also adds date and time to the message. The simplest case is: import rotifer.core.functions as cf if verbose: cf.vmsg('Simple test') >> ## [12/03/18 10:36:54] Simple test More complex usage includes passing a list of one or more elements. If a list with one element is passed, the output message will behave the same as passing a string Example: import rotifer.core.functions as cf cf.vmsg(['Simple test']) >> ## [12/03/18 10:36:54] Simple test If a list with more than one element is passed, each element is printed in one line. Please note that the first line will contain the time log, subsequent lines will be printed with three '#'. Example import rotifer.core.functions as cf cf.vmsg(['Complex test', 'line1', 'line2']) >> ## [12/03/18 10:36:54] Simple test >> ### line1 >> ### line2","title":"vmsg"},{"location":"modules/core/functions/#dotdict","text":"This is a silly class to access dictionary attributes using dot annotation. Common dictionary usage in python uses, dict['KEY'] to access the value. Using this class you can access the attribute using dot (.), as dict.KEY. It may be usefull to save some typing or sometimes is very handy to use this type of annotation. Example: import rotifer.core.functions as cf cf.dotdict({'apple': 0, 'banana':10, 'orange':20}) print(cf.apple) >> 0 Modifying values import rotifer.core.functions as cf cf.dotdict({'apple': 0, 'banana':10, 'orange':20}) cf.apple = 3 print(cf.apple) >> 3 Passing a dict import rotifer.core.functions as cf common_dictionary = {'apple': 0, 'banana':10, 'orange':20} cf.dotdict(common_dictionary) print(cf.apple) >> 0","title":"dotdict"},{"location":"modules/neighborhood/","text":"","title":"Content"},{"location":"modules/neighborhood/neighborhood/","text":"","title":"Neighborhood"},{"location":"modules/tools/","text":"The core module Rotifer package containing tools. Search module A package to perform search operation Domain module A package to work with domains table","title":"Content"},{"location":"modules/tools/#the-core-module","text":"Rotifer package containing tools.","title":"The core module"},{"location":"modules/tools/#search-module","text":"A package to perform search operation","title":"Search module"},{"location":"modules/tools/#domain-module","text":"A package to work with domains table","title":"Domain module"},{"location":"modules/tools/domain/","text":"Domain package This package allow you to manipulate a domain table Quick Start This package accepts a domain table, or more broadly a pandas dataframe. A simple input table consist of: ID domain start end evalue WP_011523244.1 Reg_prop 270 290 1.00e-02 WP_011523244.1 Reg_prop 392 412 5.20e-03 WP_011523244.1 Y_Y_Y 690 752 2.10e-15 WP_011523244.1 HisKA_3 799 864 5.70e-13 WP_011523244.1 HATPase_c 915 1004 1.10e-07 This is a output of rotifer.tools.search().parser().hmmscan_parsed or using architecture2table. Loading the data: from rotifer import domain # The df is a pandas dataframe containing the domain table dom = domain(df) After loading the data, the corresponding domain dataframe can be accessed using the domain attribute or using the object name. The main difference is that the domain attribute is a pandas dataframe while the dom (in the example) is a object belonging to the class domain. dom = domain(df) # Similar output dom.domain >>> ID domain start end evalue 0 WP_011523244.1 Reg_prop 270 290 1.000000e-02 1 WP_011523244.1 Reg_prop 392 412 5.200000e-03 2 WP_011523244.1 Y_Y_Y 690 752 2.100000e-15 3 WP_011523244.1 HisKA_3 799 864 5.700000e-13 4 WP_011523244.1 HATPase_c 915 1004 1.100000e-07 dom >>> ID domain start end evalue 0 WP_011523244.1 Reg_prop 270 290 1.000000e-02 1 WP_011523244.1 Reg_prop 392 412 5.200000e-03 2 WP_011523244.1 Y_Y_Y 690 752 2.100000e-15 3 WP_011523244.1 HisKA_3 799 864 5.700000e-13 4 WP_011523244.1 HATPase_c 915 1004 1.100000e-07 Therefore all pandas dataframe operations are possible when we access the domain attribute. Domain length To measure the domain length is simple using the domain_len method. Using the above example we have: dom.domain_len() ID domain start end evalue 5 0 WP_011523244.1 Reg_prop 270 290 1.00e-02 21 1 WP_011523244.1 Reg_prop 392 412 5.20e-03 21 2 WP_011523244.1 Y_Y_Y 690 752 2.10e-15 63 3 WP_011523244.1 HisKA_3 799 864 5.70e-13 66 4 WP_011523244.1 HATPase_c 915 1004 1.10e-07 90 Some parameters includes, the start_col and end_col, indicating the domain \"start\" and \"end\". The col_name is the ouput column. The inplace parameter if True will modify the domain dataframe. To change to column name with the calculated size use col_name. dom.domain_len(col_name = 'Size') ID domain start end evalue Size 0 WP_011523244.1 Reg_prop 270 290 1.00e-02 21 1 WP_011523244.1 Reg_prop 392 412 5.20e-03 21 2 WP_011523244.1 Y_Y_Y 690 752 2.10e-15 63 3 WP_011523244.1 HisKA_3 799 864 5.70e-13 66 4 WP_011523244.1 HATPase_c 915 1004 1.10e-07 90 Filter by size col => Size col max_length = min_length inplace Distribution Calculate domain distribution col domain column col_name merge sort, ascending frequency frequency_col_name plot size percentiles Add sequence slice sequence seq len","title":"Domain"},{"location":"modules/tools/domain/#domain-package","text":"This package allow you to manipulate a domain table","title":"Domain package"},{"location":"modules/tools/domain/#quick-start","text":"This package accepts a domain table, or more broadly a pandas dataframe. A simple input table consist of: ID domain start end evalue WP_011523244.1 Reg_prop 270 290 1.00e-02 WP_011523244.1 Reg_prop 392 412 5.20e-03 WP_011523244.1 Y_Y_Y 690 752 2.10e-15 WP_011523244.1 HisKA_3 799 864 5.70e-13 WP_011523244.1 HATPase_c 915 1004 1.10e-07 This is a output of rotifer.tools.search().parser().hmmscan_parsed or using architecture2table. Loading the data: from rotifer import domain # The df is a pandas dataframe containing the domain table dom = domain(df) After loading the data, the corresponding domain dataframe can be accessed using the domain attribute or using the object name. The main difference is that the domain attribute is a pandas dataframe while the dom (in the example) is a object belonging to the class domain. dom = domain(df) # Similar output dom.domain >>> ID domain start end evalue 0 WP_011523244.1 Reg_prop 270 290 1.000000e-02 1 WP_011523244.1 Reg_prop 392 412 5.200000e-03 2 WP_011523244.1 Y_Y_Y 690 752 2.100000e-15 3 WP_011523244.1 HisKA_3 799 864 5.700000e-13 4 WP_011523244.1 HATPase_c 915 1004 1.100000e-07 dom >>> ID domain start end evalue 0 WP_011523244.1 Reg_prop 270 290 1.000000e-02 1 WP_011523244.1 Reg_prop 392 412 5.200000e-03 2 WP_011523244.1 Y_Y_Y 690 752 2.100000e-15 3 WP_011523244.1 HisKA_3 799 864 5.700000e-13 4 WP_011523244.1 HATPase_c 915 1004 1.100000e-07 Therefore all pandas dataframe operations are possible when we access the domain attribute.","title":"Quick Start"},{"location":"modules/tools/domain/#domain-length","text":"To measure the domain length is simple using the domain_len method. Using the above example we have: dom.domain_len() ID domain start end evalue 5 0 WP_011523244.1 Reg_prop 270 290 1.00e-02 21 1 WP_011523244.1 Reg_prop 392 412 5.20e-03 21 2 WP_011523244.1 Y_Y_Y 690 752 2.10e-15 63 3 WP_011523244.1 HisKA_3 799 864 5.70e-13 66 4 WP_011523244.1 HATPase_c 915 1004 1.10e-07 90 Some parameters includes, the start_col and end_col, indicating the domain \"start\" and \"end\". The col_name is the ouput column. The inplace parameter if True will modify the domain dataframe. To change to column name with the calculated size use col_name. dom.domain_len(col_name = 'Size') ID domain start end evalue Size 0 WP_011523244.1 Reg_prop 270 290 1.00e-02 21 1 WP_011523244.1 Reg_prop 392 412 5.20e-03 21 2 WP_011523244.1 Y_Y_Y 690 752 2.10e-15 63 3 WP_011523244.1 HisKA_3 799 864 5.70e-13 66 4 WP_011523244.1 HATPase_c 915 1004 1.10e-07 90","title":"Domain length"},{"location":"modules/tools/domain/#filter-by-size","text":"col => Size col max_length = min_length inplace","title":"Filter by size"},{"location":"modules/tools/domain/#distribution","text":"Calculate domain distribution col domain column col_name merge sort, ascending frequency frequency_col_name","title":"Distribution"},{"location":"modules/tools/domain/#plot-size","text":"","title":"plot size"},{"location":"modules/tools/domain/#percentiles","text":"","title":"percentiles"},{"location":"modules/tools/domain/#add-sequence","text":"","title":"Add sequence"},{"location":"modules/tools/domain/#slice-sequence","text":"seq len","title":"slice sequence"},{"location":"modules/tools/search/","text":"Command-line interface package This package allow you to create a complete command-line interface. Simple usage: The simplest usage of this package is the following: # The first 3 lines the rotifer module path import os import sys sys.insert(0, '/home/kaihami/mymodules') # Importing the corecli package import rotifer.core.cli as corecli # Allow shell autocomplete import argcomplete __version__ = 0.01 __authors__ = 'Author1; Author2' def parse_cli: # Create multiple argument parser parser = corecli.parser() parser.add_argument('--foo') # Add your arguments here # Add version control parser.add_argument('--version', action = 'version', version = __version__, authors = __authors__, program = os.path.basename(__file__), description = 'A small description' ) # Add configdump, configfile and fun parser2 = corecli.config().input() parser_merged = corecli.merge_parser( parents = [parser, parser2]) # Merge all parsers in one argcomplete.autocomplete(parser_merged) # Allow tab autocomplete args = corecli.parseargs(parser_merged) return args Actions: Default actions: Argparse offers a variety of default actions. The most important actions are covered here, for more information please check argparse manual. append : This action stores a list, and append an argument to the list. import rotifer.core.cli as corecli parser = corecli.parser() parser.add_argument('--mylist', action = 'append') parser.parse_arg('--mylist apple --mylist banana') >> Namespace(mylist=['apple', 'banana']) count This action count the number of times a keyword occurred. Usefull for verbose control. import rotifer.core.cli as corecli parser = corecli.parser() parser.add_argument('-v', '--verbose' action = 'count') If the user pass in the command-line -v or --verbose it will count +1. The user can use -v -v or -vv both will result in verbose = 2. Custom actions: There are two custom actions, the autoload and autoopen described below. autoload This action open and load a file in the memory returning a list of strings. Also, this action can remove (or not) duplicated lines in the file (non-redundant accession for example) and accepts pipe ( '|' ) from the command-line. To remove duplicated lines (default) set duplicates = False . To keep duplicated lines set duplicates = True . One important behaviour when duplicates = False is that the original order is not the same as the input. Usually this action is used with nargs = '*' as showed in the example below. Example: Removing duplicated lines. For example, to remove duplicated accessions from a file import rotifer.core.cli as corecli def parse_cli(): # Create an argument parser parser = corecli.parser() # Add argument with autoload action parser.add_argument('accessions', action = corecli.autoload, nargs = '*') args = corecli.parseargs(parser) return args if __name__ == '__main__': args = parse_cli() print(args.accessions) Keep duplicated lines in the file. For example, when reading a fasta file (each line is an element in the list). import rotifer.core.cli as corecli def parse_cli(): # Create an argument parser parser = corecli.parser() # Add argument with autoload action parser.add_argument('fasta', nargs = '*', action = corecli.autoload, duplicates = False, ) args = corecli.parseargs(parser) return args if __name__ == '__main__': args = parse_cli() print(args.fasta) autoopen TODO Functions: parser Add a argument parser This function substitutes argparse.ArgumentParser(). If you decide to use this function there is no need to import argparse in the program. The add_help is set to False. This is handy if you use corecli.merge_parser (see above). def parser(description = None): return argparse.ArgumentParser(add_help = False, description = description, formatter_class = argparse.RawTextHelpFormatter) Usage example: import rotifer.core.cli as corecli parser = corecli.parser() parser.add_argument(--foo) # same syntax as argparse ... merge_parser This function merge multiple parsers in one. For example, with this function is possible to merge a custom parser with the core parser (containing configfile, configdump and fun). import rotifer.core.cli as corecli def parse_cli: # Create multiple argument parser parser = corecli.parser() parser.add_argument('--foo') # Add your arguments here # Add configdump, configfile and fun parser2 = corecli.config().input() # A new parser parser3 = corecli.parser() parser3.add_argument('--bar') parser_merged = corecli.merge_parser( parents = [parser, parser2, parser3]) # Merge all parsers in one args = corecli.parseargs(parser_merged) return args In this example, three parsers were created: parser, parser2, and parser3. The arguments were merged using merge_parser() function. Usually this function is usefull to merge the rotifer cli with a program specific parser (see Simple Usage ) parseargs This function parse the arguments, it is important to use this function if configdump/configfile is present. It will dump/update the values. You can exclude arguments to be not present in the config file, usually a user input file. This is possible using exclude_from_dump option, the input is a list with argument to exclude. Example: import rotifer.core.cli as corecli def parse_cli(): # Create an argument parser parser = corecli.parser() # Add argument with autoload action parser.add_argument('accessions', action = corecli.autoload, nargs = '*') parser2 = corecli.config().input() parser_merged = corecli.merge_parser(parents = [parser, parser2]) args = corecli.parseargs(parser, exclude_from_dump = ['accessions']) return args if __name__ == '__main__': args = parse_cli() ... A fun option In the corecli.config().input() there is a hidden option called fun. To activate this flag the user should input myscript --fun . This will turn args.fun == True and you can print to the user two outputs (fun or nofun). Usually if the programs finished with no errors you can print the fun message, otherwise the nofun message. A simple case of fun or nofun is the following import sys import rotifer.core.cli as corecli def parse_cli(): # Create an argument parser parser = corecli.parser() # Add argument with autoload action parser.add_argument('accessions', action = corecli.autoload, nargs = '*') parser2 = corecli.config().input() parser_merged = corecli.merge_parser(parents = [parser, parser2]) args = corecli.parseargs(parser, exclude_from_dump = ['accessions']) return args if __name__ == '__main__': args = parse_cli() try: # Long program # finished everything if args.fun: sys.stderr.write(args.fun.fun) except ...: # Catch some error if args.fun: sys.stderr.write(args.fun.nofun)","title":"Search"},{"location":"modules/tools/search/#command-line-interface-package","text":"This package allow you to create a complete command-line interface.","title":"Command-line interface package"},{"location":"modules/tools/search/#simple-usage","text":"The simplest usage of this package is the following: # The first 3 lines the rotifer module path import os import sys sys.insert(0, '/home/kaihami/mymodules') # Importing the corecli package import rotifer.core.cli as corecli # Allow shell autocomplete import argcomplete __version__ = 0.01 __authors__ = 'Author1; Author2' def parse_cli: # Create multiple argument parser parser = corecli.parser() parser.add_argument('--foo') # Add your arguments here # Add version control parser.add_argument('--version', action = 'version', version = __version__, authors = __authors__, program = os.path.basename(__file__), description = 'A small description' ) # Add configdump, configfile and fun parser2 = corecli.config().input() parser_merged = corecli.merge_parser( parents = [parser, parser2]) # Merge all parsers in one argcomplete.autocomplete(parser_merged) # Allow tab autocomplete args = corecli.parseargs(parser_merged) return args","title":"Simple usage:"},{"location":"modules/tools/search/#actions","text":"","title":"Actions:"},{"location":"modules/tools/search/#default-actions","text":"Argparse offers a variety of default actions. The most important actions are covered here, for more information please check argparse manual.","title":"Default actions:"},{"location":"modules/tools/search/#append","text":"This action stores a list, and append an argument to the list. import rotifer.core.cli as corecli parser = corecli.parser() parser.add_argument('--mylist', action = 'append') parser.parse_arg('--mylist apple --mylist banana') >> Namespace(mylist=['apple', 'banana'])","title":"append:"},{"location":"modules/tools/search/#count","text":"This action count the number of times a keyword occurred. Usefull for verbose control. import rotifer.core.cli as corecli parser = corecli.parser() parser.add_argument('-v', '--verbose' action = 'count') If the user pass in the command-line -v or --verbose it will count +1. The user can use -v -v or -vv both will result in verbose = 2.","title":"count"},{"location":"modules/tools/search/#custom-actions","text":"There are two custom actions, the autoload and autoopen described below.","title":"Custom actions:"},{"location":"modules/tools/search/#autoload","text":"This action open and load a file in the memory returning a list of strings. Also, this action can remove (or not) duplicated lines in the file (non-redundant accession for example) and accepts pipe ( '|' ) from the command-line. To remove duplicated lines (default) set duplicates = False . To keep duplicated lines set duplicates = True . One important behaviour when duplicates = False is that the original order is not the same as the input. Usually this action is used with nargs = '*' as showed in the example below. Example: Removing duplicated lines. For example, to remove duplicated accessions from a file import rotifer.core.cli as corecli def parse_cli(): # Create an argument parser parser = corecli.parser() # Add argument with autoload action parser.add_argument('accessions', action = corecli.autoload, nargs = '*') args = corecli.parseargs(parser) return args if __name__ == '__main__': args = parse_cli() print(args.accessions) Keep duplicated lines in the file. For example, when reading a fasta file (each line is an element in the list). import rotifer.core.cli as corecli def parse_cli(): # Create an argument parser parser = corecli.parser() # Add argument with autoload action parser.add_argument('fasta', nargs = '*', action = corecli.autoload, duplicates = False, ) args = corecli.parseargs(parser) return args if __name__ == '__main__': args = parse_cli() print(args.fasta)","title":"autoload"},{"location":"modules/tools/search/#autoopen","text":"TODO","title":"autoopen"},{"location":"modules/tools/search/#functions","text":"","title":"Functions:"},{"location":"modules/tools/search/#parser","text":"Add a argument parser This function substitutes argparse.ArgumentParser(). If you decide to use this function there is no need to import argparse in the program. The add_help is set to False. This is handy if you use corecli.merge_parser (see above). def parser(description = None): return argparse.ArgumentParser(add_help = False, description = description, formatter_class = argparse.RawTextHelpFormatter) Usage example: import rotifer.core.cli as corecli parser = corecli.parser() parser.add_argument(--foo) # same syntax as argparse ...","title":"parser"},{"location":"modules/tools/search/#merge_parser","text":"This function merge multiple parsers in one. For example, with this function is possible to merge a custom parser with the core parser (containing configfile, configdump and fun). import rotifer.core.cli as corecli def parse_cli: # Create multiple argument parser parser = corecli.parser() parser.add_argument('--foo') # Add your arguments here # Add configdump, configfile and fun parser2 = corecli.config().input() # A new parser parser3 = corecli.parser() parser3.add_argument('--bar') parser_merged = corecli.merge_parser( parents = [parser, parser2, parser3]) # Merge all parsers in one args = corecli.parseargs(parser_merged) return args In this example, three parsers were created: parser, parser2, and parser3. The arguments were merged using merge_parser() function. Usually this function is usefull to merge the rotifer cli with a program specific parser (see Simple Usage )","title":"merge_parser"},{"location":"modules/tools/search/#parseargs","text":"This function parse the arguments, it is important to use this function if configdump/configfile is present. It will dump/update the values. You can exclude arguments to be not present in the config file, usually a user input file. This is possible using exclude_from_dump option, the input is a list with argument to exclude. Example: import rotifer.core.cli as corecli def parse_cli(): # Create an argument parser parser = corecli.parser() # Add argument with autoload action parser.add_argument('accessions', action = corecli.autoload, nargs = '*') parser2 = corecli.config().input() parser_merged = corecli.merge_parser(parents = [parser, parser2]) args = corecli.parseargs(parser, exclude_from_dump = ['accessions']) return args if __name__ == '__main__': args = parse_cli() ...","title":"parseargs"},{"location":"modules/tools/search/#a-fun-option","text":"In the corecli.config().input() there is a hidden option called fun. To activate this flag the user should input myscript --fun . This will turn args.fun == True and you can print to the user two outputs (fun or nofun). Usually if the programs finished with no errors you can print the fun message, otherwise the nofun message. A simple case of fun or nofun is the following import sys import rotifer.core.cli as corecli def parse_cli(): # Create an argument parser parser = corecli.parser() # Add argument with autoload action parser.add_argument('accessions', action = corecli.autoload, nargs = '*') parser2 = corecli.config().input() parser_merged = corecli.merge_parser(parents = [parser, parser2]) args = corecli.parseargs(parser, exclude_from_dump = ['accessions']) return args if __name__ == '__main__': args = parse_cli() try: # Long program # finished everything if args.fun: sys.stderr.write(args.fun.fun) except ...: # Catch some error if args.fun: sys.stderr.write(args.fun.nofun)","title":"A fun option"},{"location":"programs/acc2operon/","text":"Acc2operon Retrieving neighborhood with acc2operon Command: acc2operon [-options] <protein_accession> 1. Simple Usage The simplest form to get a gene neighborhood is using a protein accession. acc2operon AAF37898.1 Also, acc2operon accepts a file containing a list of protein accession. Each accession must be in a new line. cat proteins.acc >> ALA74808.1 >> ANB85424.1 >> ASO61569.1 >> AMS29978.1 >> ASB67180.1 >> NP_355129.1 >> AWK11510.1 >> AMQ86316.2 >> NP_417993.1 >> AKP44116.1 acc2operon proteins.acc 2. Options Valid options includes: Option Default value --above/-a 3 --below/-b 3 --threads/-t 5 --outformat/-of table --search_method/-sm www --hit_method/-hm best --progress/-p --api_key None --header/-y None --configdump None --configfile None 2.01 Above To collect more genes above the query, activate the flag --above or -a and insert how many genes above the query, the default value is 3 . acc2operon -a 3 <protein_accession> 2.02 below To collect more genes below the query, activate the flag --below or -b and insert how many genes below the query, the default value is 3 . acc2operon -b 3 <protein_accession> 2.03 threads 2.04 outformat 2.05 search method 2.06 hit method 2.07 progress 2.08 api key 2.09 header 2.10 configdump 2.11 configfile 3. Dev Developing this program includes: Develop the rotifer.genome.database module Develop the rotifer.genome.data module 3.1 Block definition We discussed about what is the minimun information that represents a genome data (block). This feature is particular important to model a better database (current using clickhouse, but keep in mind other DB must be included like MS SQL and postgres). The minimun columns in a dataframe that defines an object belonging to rotifer.genome.data is: nucleotide type start end strand feature_id block_id 3.2 Things to implement Splicing and origin A known issue regards when a feature is composed by more than one location (See Bio.SeqFeature, BioPython module). When such feature occurs, like in spliced genes and/or features overlapping the origin this leads to an incorrect result. To overcome this issue a possible solution is: The signature of a compound feature is the presence of at least one pair of features, when sorted by position (start, end), includes: A feature whose end coordinate is equal to the maximum value of any end coordinate for the corresponding nucleotide/contig. (Feature_end = end_max) The next feature start coordinate is equal to the minimum start of all features of the corresponding nucleotide/contig. (Feature_start = start_min) The presence of these properties implies that any feature, spliced or not, runs over the origin of a circular replicon. Annotation reference Add a table to store generic annotation and references to external data for each feature. Keep in mind that each feature if identified by the feature_order and the nucletide accession. That applies even to the compound/spliced features, that will span several rows in our main table, one row per location. feature_order nucleotide_id Attribute Database Value 1 NZ121321.1 db_xref GeneID 316 1 NZ121321.1 db_xref taxon 457400 Minimize the number of SQL queries Try to minimize the number of SQL queries needed to identify the nucleotide accessions and genome_order intervals. Add a new table to database We might, in the future, use a table that related pairs of features with a qualifier, like: gene1 cds1 coded_by gene1 mrna1 transcript How to represent a CompoundFeature in the dataframe? A compound feature, or a gene with multiple isoforms. Internally the rotifer.genome.data must know how many isoforms per gene, where are the all possible valid combinations. One way to go is to represent several isoforms as CompoundFeatures. Each gene may have several CompoundFeatures. For example, the user may want to know how many isoforms and the isoform protein sequence. How to represent such abstract data? Multiple lines, each line representing one isoform? If a user select one gene it will represent several isoforms? How we will represent it inside the rotifer.genome.data? It will be a new pandas datatype? How to implement this class (inheritance from BioSeq) inside a pandas dataframe, it will be slow?","title":"acc2operon"},{"location":"programs/acc2operon/#acc2operon","text":"Retrieving neighborhood with acc2operon Command: acc2operon [-options] <protein_accession>","title":"Acc2operon"},{"location":"programs/acc2operon/#1-simple-usage","text":"The simplest form to get a gene neighborhood is using a protein accession. acc2operon AAF37898.1 Also, acc2operon accepts a file containing a list of protein accession. Each accession must be in a new line. cat proteins.acc >> ALA74808.1 >> ANB85424.1 >> ASO61569.1 >> AMS29978.1 >> ASB67180.1 >> NP_355129.1 >> AWK11510.1 >> AMQ86316.2 >> NP_417993.1 >> AKP44116.1 acc2operon proteins.acc","title":"1. Simple Usage"},{"location":"programs/acc2operon/#2-options","text":"Valid options includes: Option Default value --above/-a 3 --below/-b 3 --threads/-t 5 --outformat/-of table --search_method/-sm www --hit_method/-hm best --progress/-p --api_key None --header/-y None --configdump None --configfile None","title":"2. Options"},{"location":"programs/acc2operon/#201-above","text":"To collect more genes above the query, activate the flag --above or -a and insert how many genes above the query, the default value is 3 . acc2operon -a 3 <protein_accession>","title":"2.01 Above"},{"location":"programs/acc2operon/#202-below","text":"To collect more genes below the query, activate the flag --below or -b and insert how many genes below the query, the default value is 3 . acc2operon -b 3 <protein_accession>","title":"2.02 below"},{"location":"programs/acc2operon/#203-threads","text":"","title":"2.03 threads"},{"location":"programs/acc2operon/#204-outformat","text":"","title":"2.04 outformat"},{"location":"programs/acc2operon/#205-search-method","text":"","title":"2.05 search method"},{"location":"programs/acc2operon/#206-hit-method","text":"","title":"2.06 hit method"},{"location":"programs/acc2operon/#207-progress","text":"","title":"2.07 progress"},{"location":"programs/acc2operon/#208-api-key","text":"","title":"2.08 api key"},{"location":"programs/acc2operon/#209-header","text":"","title":"2.09 header"},{"location":"programs/acc2operon/#210-configdump","text":"","title":"2.10 configdump"},{"location":"programs/acc2operon/#211-configfile","text":"","title":"2.11 configfile"},{"location":"programs/acc2operon/#3-dev","text":"Developing this program includes: Develop the rotifer.genome.database module Develop the rotifer.genome.data module","title":"3. Dev"},{"location":"programs/acc2operon/#31-block-definition","text":"We discussed about what is the minimun information that represents a genome data (block). This feature is particular important to model a better database (current using clickhouse, but keep in mind other DB must be included like MS SQL and postgres). The minimun columns in a dataframe that defines an object belonging to rotifer.genome.data is: nucleotide type start end strand feature_id block_id","title":"3.1 Block definition"},{"location":"programs/acc2operon/#32-things-to-implement","text":"","title":"3.2 Things to implement"},{"location":"programs/acc2operon/#splicing-and-origin","text":"A known issue regards when a feature is composed by more than one location (See Bio.SeqFeature, BioPython module). When such feature occurs, like in spliced genes and/or features overlapping the origin this leads to an incorrect result. To overcome this issue a possible solution is: The signature of a compound feature is the presence of at least one pair of features, when sorted by position (start, end), includes: A feature whose end coordinate is equal to the maximum value of any end coordinate for the corresponding nucleotide/contig. (Feature_end = end_max) The next feature start coordinate is equal to the minimum start of all features of the corresponding nucleotide/contig. (Feature_start = start_min) The presence of these properties implies that any feature, spliced or not, runs over the origin of a circular replicon.","title":"Splicing and origin"},{"location":"programs/acc2operon/#annotation-reference","text":"Add a table to store generic annotation and references to external data for each feature. Keep in mind that each feature if identified by the feature_order and the nucletide accession. That applies even to the compound/spliced features, that will span several rows in our main table, one row per location. feature_order nucleotide_id Attribute Database Value 1 NZ121321.1 db_xref GeneID 316 1 NZ121321.1 db_xref taxon 457400","title":"Annotation reference"},{"location":"programs/acc2operon/#minimize-the-number-of-sql-queries","text":"Try to minimize the number of SQL queries needed to identify the nucleotide accessions and genome_order intervals.","title":"Minimize the number of SQL queries"},{"location":"programs/acc2operon/#add-a-new-table-to-database","text":"We might, in the future, use a table that related pairs of features with a qualifier, like: gene1 cds1 coded_by gene1 mrna1 transcript","title":"Add a new table to database"},{"location":"programs/acc2operon/#how-to-represent-a-compoundfeature-in-the-dataframe","text":"A compound feature, or a gene with multiple isoforms. Internally the rotifer.genome.data must know how many isoforms per gene, where are the all possible valid combinations. One way to go is to represent several isoforms as CompoundFeatures. Each gene may have several CompoundFeatures. For example, the user may want to know how many isoforms and the isoform protein sequence. How to represent such abstract data? Multiple lines, each line representing one isoform? If a user select one gene it will represent several isoforms? How we will represent it inside the rotifer.genome.data? It will be a new pandas datatype? How to implement this class (inheritance from BioSeq) inside a pandas dataframe, it will be slow?","title":"How to represent a CompoundFeature in the dataframe?"},{"location":"programs/mcube/","text":"","title":"Mcube"},{"location":"programs/rneighbors/","text":"","title":"Rneighbors"},{"location":"programs/rnexplorer/","text":"","title":"Rnexplorer"}]}