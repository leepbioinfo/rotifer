# POD documentation - main docs before the code

=head1 NAME

Rotifer::DBIC::AnnotationDB::Parser::operon - gene neighborhoods by gi2operons (planned) 

=head1 SYNOPSIS

  # Using this parser with rotiferDB command line app
  #
  # Note: this will automatically create a biograph
  #       and add all sequences to it

  rotiferDB -a load -if operon te.operon

  # Creating a new parser
  use Rotifer::DBIC::IO;
  my $parser = Rotifer::DBIC::IO->create("operon");
  $parser->load(@ARGV);

=head1 DESCRIPTION

Rotifer::DBIC::AnnotationDB::Parser::operon will load data on genes located near a
pivot gene (as generated by gi2operons) into a Rotifer::DBIC 
database. 

=head1 AUTHOR

Robson Francisco de Souza

Email robfsouza at gmail.com

=head1 CONTRIBUTORS

Additional contributors names and emails here

=head1 DEPENDENCIES

=over

=item Moose

=item Rotifer::DBIC

=item Carp::Clan

=back

=head1 APPENDIX

The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _

=cut

package Rotifer::DBIC::AnnotationDB::Parser::operon;

use strict;
use warnings;
use autodie qw(:all);
use Carp::Clan qr/^Rotifer::DBIC::AnnotationDB/;
use Moose;
extends 'Rotifer::DBIC::AnnotationDB::Parser::gi';

=head2 ATTRIBUTES

=head2 tags

 Usage   : $parser->tags
 Function: annotation tags used by this parser
 Returns : Rotifer::DBIC::Result::Term
 Builder : _default_tags

 The following tags will be added to the parser vocabulary

 operon file : gi2operons output

=cut

sub _default_tags {
    my ($self) = shift;

    my @tags = 
	(
	 {
	     name       => 'operon file',
	     definition => "Lists of gene neighborhoods around target genes created by gi2operons.",
	 },
	);

    return $self->next::method(@tags, @_);
}

=head2 METHODS

=head2 load

 Title   : load
 Usage   : $full_path = $parser->load("data.txt")
 Function: process and load data from all input files
 Returns : 
 Args    : list of file names

=cut

sub load {
    my ($self, @input) = @_;
    return 1;

    # Parse input
    my %proteins = $self->parse_operons(@ARGV);
    $self->next::method(keys %proteins);
    my @nodes = $self->process_locations(%proteins);

    return ;
}

=head2 parse_operons

 Title   : parse_operons
 Usage   : $full_path = $self->parse_operons("data.txt")
 Function: parse architecture table into an array of hashes 
 Returns : hash of arrays (input table's first column is the key) 
 Args    : list of file names

=cut

sub parse_operons {
    my ($self, @files) = @_;

    foreach my $file (@files) {
	open(my $fh,"<$file");
	my $nucleotide   = undef;
	my $neighborhood = 0;
	my $row_number   = 0;
	while (<$fh>) {
	    chomp;
	    next if /^[\-\s]*$/;
	    next if /\.*\S*cds\s+dir\s+/;

	    # Header
	    if (/ORGANISM\s+(.+)\s+accession\s+no\s+is\s+(\S+)\s+gi\s+is\s+(\d+)/) {
		$nucleotide   = $2;
		$neighborhood++;
		next;
	    }

	    # Data
	    my $is_target = /^-->/ ? 1 : 0;
	    my @row = split(/\s+/,$_,9);
	    croak "File $file contains non-numeric GI at row ${row_number}: fix it!" if ($row[4] !~ /^\d+/);

	    print join("\t",$nucleotide,@row[1,2,4],$neighborhood,$is_target),"\n";

	    $row_number++;
	}
	close($fh);
    }
}

__PACKAGE__->meta->make_immutable;
1;
